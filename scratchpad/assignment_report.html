<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Janith Wanniarachchi">

<title>Explaining Anchors: High precision model agnostic explanations</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="assignment_report_files/libs/clipboard/clipboard.min.js"></script>
<script src="assignment_report_files/libs/quarto-html/quarto.js"></script>
<script src="assignment_report_files/libs/quarto-html/popper.min.js"></script>
<script src="assignment_report_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="assignment_report_files/libs/quarto-html/anchor.min.js"></script>
<link href="assignment_report_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="assignment_report_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="assignment_report_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="assignment_report_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="assignment_report_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Explaining Anchors: High precision model agnostic explanations</h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
<p class="subtitle lead">BEX6510 Foundations of Econometrics</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Janith Wanniarachchi </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<!--
The summary and presentation slides should contain an empirical verification of the main argument, whether it is a simulation study or an application based on the real data. 
The codes related to this exercise should be submitted along with the summary and the slides. 
-->
<!--
In doing so, notice the way the paper has been organised and arguments have been developed. 
In particular, see if you can demonstrate how every claim in the paper is backed up by evidence or proof. 
In addition to introducing to you some papers of high quality not only directly or indirectly related to the material that we are learning but also related to your research area, another goal is that you see the writing style and the organisation of papers that have been published in high quality journals. Last but not least, familiarise yourself with statistical software packages/tools.
-->
<!--
 There will be additional marks when a student extends, generalises and demonstrates novelty beyond the review or a straightforward implementation or extension of the paper under review.
-->
<section id="from-building-black-box-models-to-explaining-black-box-models" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> From building black box models to explaining black box models</h1>
<p>Machine learning has grown from being a niche curiosity in computer science to dominating decision making processes in a variety of contexts. Thereby leading to the need to ensure that the decisions that are automated by computational systems are unbiased, accountable, and transparent. Traditionally, automated decision making was done through statistical models such as linear regression, which were inherently interpretable as models were defined based on distributional assumptions about the data and restricted the model complexity. However, these assumptions did not hold for long as began to be accumulated from many sources with higher variety, resulting in interpretable white box models failing to keep up with the desired performance. Novel machine learning models allow researchers to let the model define the functional form of the decision process. As more of our decision making processes are automated through complex models, the need to answer the question: ”How did the model arrive at this decision?” has started to gain traction over the past few years <span class="citation" data-cites="molnar_interpretable_2020">(<a href="#ref-molnar_interpretable_2020" role="doc-biblioref">Molnar, Casalicchio, and Bischl 2020</a>)</span>.</p>
<p>Explainable AI is a research area that develops statistical and algorithmic techniques to approximate and communicate the decision process of black box models. There are many classifications of explainable AI methods, and the two most prominent classifications are centered around the model agnosticism and the scope of explanations. Explainable AI methods that are capable of explaining any black box models are called model agnostic methods where the internal parameters or gradients are not utilized to explain the model. On the other hand, there are model specific methods that utilize the structure of the black box model such as the weights and gradients of neural networks to provide explanations. In terms of the scope of explanations, an explaination can be capable of explaining the entire decision process of the entire training data instances or for a single data instance. The former would be called global explaination methods while the latter will be called local explaination methods. Examples for global explaination methods would include Partial Dependence Plots and Individual Conditional Effects while examples of local explaination methods would include LIME, SHAP and Counterfactuals <span class="citation" data-cites="molnar_interpretable_2022">(<a href="#ref-molnar_interpretable_2022" role="doc-biblioref">Molnar 2022</a>)</span>.</p>
<p>This report will discuss and review the paper “Anchors: High precision model agnostic explanations” <span class="citation" data-cites="ribeiro_anchors:_2018">(<a href="#ref-ribeiro_anchors:_2018" role="doc-biblioref">Ribeiro, Singh, and Guestrin 2018</a>)</span>. The structure of this report will be as follows. <a href="#sec-what-are-anchors">Section&nbsp;2</a> will define what anchors are and review the main arguments given by the authors of the paper. As a contribution to the existing research work, I will be providing a tutorial on what anchors are, from a simple example to complex methods using different intuitive techniques and dicussing the applicability of each method. <a href="#sec-anchors-from-scratch">Section&nbsp;3</a> will implement the fundamental concept of anchors in such incremental steps starting with one dimensional data and moving to higher dimensions. Finally, an overall review of the paper and the discussion on the process of reproducing the paper will be discussed in <a href="#sec-review">Section&nbsp;4</a>.</p>
</section>
<section id="sec-what-are-anchors" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> What are Anchors?</h1>
<section id="theoretical-definition" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="theoretical-definition"><span class="header-section-number">2.1</span> Theoretical definition</h2>
<p>Anchors are a model agnostic method of explaining black box models which attempt to present the model’s decision process for a single given instance. In addition to providing the decision process for the given instance, anchors provide humans with the capability to predict a black box model’s behaviour on unknown instances. This is achieved by providing a set of simple decision rules that apply to a large area of the feature space containing predictions similar to the given instance.</p>
<p>The authors have defined anchors as a rule or a set of predicates that satisfy the given instance and is a sufficient condition for <span class="math inline">\(f(x)\)</span> (i.e.&nbsp;the model output) with high probability.</p>
<p>A predicate is a logical condition that an observation may or may not satisfy. The simplest form of these predicates takes in the form of <span class="math inline">\(\{x_1 &gt; 2\}\)</span>. An instance with the <span class="math inline">\(x_1\)</span> feature greater than 2 would satisfy this predicate. Therefore a possible candidate for an anchor might take the form of <span class="math inline">\(\mathcal{A} = \{x_1 &gt; 2, x_1 &lt; 3, x_2 &gt; 10, x_3 &lt; 5,x_4 == 1, \dots\}\)</span>. The authors have not defined exactly how a predicate should be structured due to the wide variety of data available in the wild. Since most of our applications are on tabular data, I can assume the simplest form of orthogonal boundaries.</p>
<p>For a list of predicates to be an anchor it should satisfy the given instance while also maximizing two criteria, 1. Precision 2. Coverage</p>
<p>Let’s dive into how each of these criteria is calculated.</p>
<section id="precision" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="precision"><span class="header-section-number">2.1.1</span> Precision</h3>
<p>In the paper, precision is defined formally as <span class="math display">\[
\text{Prec}(\mathcal{A}) = \mathbb{E}_{\mathcal{D}(z|\mathcal{A})}[\mathbb{1}_{f(x) = f(z)}]
\]</span></p>
<p>Here <span class="math inline">\(\mathbb{D}\)</span> is the perturbation distribution based on the given instance <span class="math inline">\(x\)</span>.</p>
<section id="what-is-a-perturbation-distribution" class="level4" data-number="2.1.1.1">
<h4 data-number="2.1.1.1" class="anchored" data-anchor-id="what-is-a-perturbation-distribution"><span class="header-section-number">2.1.1.1</span> What is a perturbation distribution?</h4>
<p>A perturbation distribution is a method of generating varied versions of the data (kind of like alternate realities of the same data). The simplest form of a perturbation distribution would be to use a multivariate normal distribution centered around the given instance.</p>
<p>The paper argues that it is intractable to calculate the precision directly (the term directly could be meaning analytically as it is numerically possible to approximate the expected value). Therefore a list of predicates <span class="math inline">\(\mathcal{A}\)</span> is considered an anchor if <span class="math display">\[
\text{Pr}(\text{Prec}(\mathcal{A}) \ge \tau) \ge 1 - \delta
\]</span></p>
<p>From an implementation perspective, the precision of the anchor would then be the proportion of data points from the perturbation distribution with the same class as the given instance within the boundary of the anchor.</p>
</section>
</section>
<section id="coverage" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="coverage"><span class="header-section-number">2.1.2</span> Coverage</h3>
<p>The paper defines the coverage of an anchor <span class="math inline">\(A\)</span> as the probability that it applies to samples from <span class="math inline">\(\mathcal{D}\)</span>, <span class="math inline">\(\text{cov}(\mathcal{A}) = \mathbb{E}_{\mathcal{D}(z)}[\mathcal{A}(z)]\)</span>. Simply put we would be calculating the proportion of samples from the perturbation distribution that satisfy the boundary of the anchor. However, this would be problematic if our perturbation distribution is dense or sparse around certain areas.</p>
<p>Therefore, I would argue that picking a boundary that captures the most of the perturbation distribution is not ideal and instead, it would be best to compute the coverage based on the proportion of the feature space that is covered. This idea will be covered in detail in <a href="#sec-def-anchors">Section&nbsp;3.1</a>.</p>
<!-- TODO: Explain the methodology that was used to build anchors. Including the construction of anchors using beam search, using multi-arm bandits and the evaluation using user studies and simulation data -->
</section>
</section>
<section id="problem-statement" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="problem-statement"><span class="header-section-number">2.2</span> Problem statement</h2>
<p>Since a list of predicates is considered to be an anchor if it maximizes the coverage and precision, finding an anchor for a given instance can be defined as the solution to the following optimization problem</p>
<p><span class="math display">\[
\max_{\mathcal{A} \text{ s.t. } \text{Pr}(\text{Prec}(\mathcal{A}) \ge \tau) \ge 1 - \delta} \text{cov}(\mathcal{A})
\]</span></p>
<p>The target would then be to maximize the coverage while ensuring that the precision is above a tolerance level. However, as an extension of this approach, I would argue that understanding the local neighbourhood of a given instance is more important than being able to extrapolate a model’s capability on unseen instances. The decision rules with large coverages are based primarily on the perturbation distribution <span class="math inline">\(\mathcal{D}\)</span> and therefore the choice of distribution can give flawed decision rules to end users who mighy only want to observe the decision rules for similar points as the given instance in the feature space.</p>
</section>
<section id="methodology" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="methodology"><span class="header-section-number">2.3</span> Methodology</h2>
<p>The authors argue that while it is possible to generate a very large dataset and use methods such as Inductive Logic Programming to find these predicates, in high dimensional sparse datasets, the number of possible samples and predictions would be limited. Therefore they have decided to formulate the problem as a multi-arm bandit <span class="citation" data-cites="gittins_dynamic_1979">(<a href="#ref-gittins_dynamic_1979" role="doc-biblioref">Gittins and Jones 1979</a>)</span> with the solution being a modified version of KL-LUCB combined with beam search to appropriately explore the possible candidates for anchors.</p>
<section id="multi-arm-bandit-problems" class="level3" data-number="2.3.1">
<h3 data-number="2.3.1" class="anchored" data-anchor-id="multi-arm-bandit-problems"><span class="header-section-number">2.3.1</span> Multi-arm bandit problems</h3>
<p>Multi-arm bandit problems are a classic problem in reinforcement learning where <span class="math inline">\(K\)</span> number of choices (“arms of poker machines”) are presented to an agent and each draw (“pull”) from a choice gives a certain reward based on an unknown probability distribution. Some arms will give higher rewards than others. The objective is to design an agent that will maximize the average reward by the end of the sequence of draws. While trying to maximize the reward the agent will have to trade-off between either exploring the available choices or exploiting the known choices that give high rewards.</p>
<p>There are different strategies used to solve these problems that attempt to balance the exploration-exploitation trade-off such as,</p>
<ol type="1">
<li>Epsilon-greedy strategy</li>
<li>Softmax strategy</li>
<li>Upper Confidence Bound strategy etc.</li>
</ol>
<p>However, in this paper, the authors have used a pure exploration method that tries to explore the possible choices as much as possible rather than exploiting the known arms.</p>
</section>
<section id="beam-search" class="level3" data-number="2.3.2">
<h3 data-number="2.3.2" class="anchored" data-anchor-id="beam-search"><span class="header-section-number">2.3.2</span> Beam search</h3>
<p>Beam search is a heuristic search algorithm similar to Best First Search and Breadth First Search in the computer science field. The target of the algorithm is to find a possible goal state in a large graph in the shortest amount of time. Beam search achieves this by performing a breadth first search with a parameter <span class="math inline">\(\beta\)</span> limiting the breadth of the graph traversal and then ordering the visible nodes by a heuristic value to select which node to traverse to next. While traversing the graph, beam search will keep a pre determined number of nodes that could potentially be goal states and discard ones that are not above valuable based on a heuristic.</p>
</section>
<section id="the-algorithm" class="level3" data-number="2.3.3">
<h3 data-number="2.3.3" class="anchored" data-anchor-id="the-algorithm"><span class="header-section-number">2.3.3</span> The algorithm</h3>
<p>The authors have demonstrated how they developed their idea by first showcasing a greedy KL-LUCB strategy <span class="citation" data-cites="kl_lucb_kaufmann">(<a href="#ref-kl_lucb_kaufmann" role="doc-biblioref">Kaufmann and Kalyanakrishnan 2013</a>)</span> based method and then extending it to include a beam search approach.</p>
<p>In the paper anchors are constructed using a bottom up strategy where they start off with an empty anchor <span class="math inline">\(\mathcal{A} = {}\)</span> that would cover the entire feature space initially. In each iteration, a set of possible predicates is generated <span class="math inline">\({a_i}, i = {1,2,\dots, k}\)</span> and the current anchor is extended with these possible predicates to create a set of possible anchors. Picking the right predicate to extend the current anchor with will be decided by the multi-arm bandit solution. In the formulated multi-arm bandit problem, the possible feature predicates were the choices while the reward from pulling a choice was the precision obtained with the pulled feature predicate in the final anchor. Once a predicate has been selected, if the current anchor combined with the new feature predicate satisfies the following criteria</p>
<p><span class="math display">\[
\text{Pr}(\text{Prec}(\mathcal{A}) \ge \tau) \ge 1 - \delta
\]</span></p>
<p>then the process terminates early to provide the derived anchor. Notice how they were not trying to maximize the coverage but were only trying to pick the candidate that gave the highest precision. Since they are starting with an empty anchor the coverage is high and with every new predicate attached the coverage reduces slowly. They assume that the anchors with a smaller number of predicates would generally have higher coverage.</p>
<p>It is limiting to have only one anchor considered as the solution as they would not be exploring other possible solutions. Therefore a set of possible anchors is considered in a beam search approach. The KL LUCB approach is modified to select <span class="math inline">\(B\)</span> number of best candidates. From these candidates, the final output will give the one with the highest coverage.</p>
</section>
</section>
<section id="evaluation" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="evaluation"><span class="header-section-number">2.4</span> Evaluation</h2>
<p>Evaluating explainability methods quantitatively is a difficult and seemingly impossible task without utilizing a user study. In this case, anchors is evaluated using both simulated and actual users.</p>
<!-- We evaluate anchor explanations for complex models on a
number of tasks, primarily focusing on how they facilitate
accurate predictions by users (simulated and human) on the
behaviour of the models on unseen instances. For simulated users, we use the tabular datasets previously
mentioned (adult, rcdv and lending). Each dataset is split
such that models are trained with the training set, explanations
are produced for instances in the validation set, and
evaluated on instances in the test set. For each dataset, we
train three different models: logistic regression (lr), 400 gradient
boosted trees (gb) and a multilayer perceptron with
two layers of 50 units each (nn).We generate both linear
LIME (Ribeiro, Singh, and Guestrin 2016b) and anchor explanations
for them. When simulating users, we compute coverage (what fraction
of the instances they predict after seeing explanations)
and precision (what fraction of the predictions were correct)
on the complete test set. For each dataset, model, and explanation
type, we compute these metrics for the explanation
of each instance in the validation data. Simulating when an
anchor applies is clear. It is not obvious, however, how real
users would use LIME explanations. Ideally, they should
only apply explanations to examples that are close, but it is
not clear what the distance function and the threshold for
“close” should be, or if users compute distances on demand.
Therefore, in this section, we simulate different behaviours,
and perform a study with real users in the following section. -->
<section id="simulated-user-study" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="simulated-user-study"><span class="header-section-number">2.4.1</span> Simulated user study</h3>
<p>The concept of simulating users is a novel and interesting concept. In this paper, the authors have used several popular tabular datasets in the machine learning field that are focused on classification tasks (e.g.&nbsp;The <code>adult</code> dataset contains features of adults in America and the task is to predict if their annual salary would be above or below 50,000$). Each dataset would be split into three components: training, validation and testing. For each training dataset, a logistic regression model, a gradient boosted tree and a multilayer perceptron were trained to derive explanations. To compare the performance of anchors they have picked a similar method of generating model agnostic local explanations called LIME<span class="citation" data-cites="ribeiro_why_2016">(<a href="#ref-ribeiro_why_2016" role="doc-biblioref">Ribeiro, Singh, and Guestrin 2016</a>)</span>. For each instance in validation datasets, explanations will be generated using both LIME and anchors. The evaluation metric was set to be coverage and precision, where coverage was calculated based on the fraction of the instances a simulated user would predict after seeing explanations while precision was calculated based on the fraction of the correct predictions taken on the complete test set. While it is easy to calculate the coverage and precision based on the explanations of anchors since they are rule based methods, calculating how a user would apply LIME explanations was difficult as LIME explanations contained only the effect of the features on a given local instance. Therefore they have simulated two user types where one group would apply the LIME explanations naively while the other group would apply the LIME explanation if it is above a certain threshold.</p>
</section>
<section id="real-world-user-study" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="real-world-user-study"><span class="header-section-number">2.4.2</span> Real world user study</h3>
<p>The real world user study utilized 26 students following a machine learning course. The users were first told to predict the behaviour of the model without seeing any explanations and also after seeing one or two rounds of explanations from LIME or anchors. The procedure and evaluation criteria were roughly similar to the simulated user study. In the real world user study, the lending dataset used in the simulated dataset has not being used and instead several visual quastion answering dataset were used. Also in addition to the coverage and precision, the time to give predictions were also considered as an evaluation metric between lime and anchors.</p>
</section>
<section id="results" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="results"><span class="header-section-number">2.4.3</span> Results</h3>
<div id="fig-sim-user-study" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="imgs/sim_user_study.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Average precision and coverage with simulated users on 3 tabular datasets and 3 classifiers.</figcaption>
</figure>
</div>
<div id="fig-real-user-study" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="imgs/real_user_study.png" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Average precision, coverage and time to provide predictions based on real world user study using 2 tabular datasets and 2 visual question answering set</figcaption>
</figure>
</div>
<p>The results of both the simulated and real world user study shows that anchors has outperformed lime in roughly all of the evaluation metrics. In both case studies, the users were able to predict the behavior of models on unseen instances precisely and in the case of the real world user study, with less effort as well (indicated by the less time it took to give predictions).</p>
</section>
</section>
<section id="existing-statistical-software" class="level2" data-number="2.5">
<h2 data-number="2.5" class="anchored" data-anchor-id="existing-statistical-software"><span class="header-section-number">2.5</span> Existing Statistical Software</h2>
<p>Currently, the anchors package has been implemented in a Java package and an R package<span class="citation" data-cites="anchors_R_pkg">(<a href="#ref-anchors_R_pkg" role="doc-biblioref">Hellweg 2023</a>)</span>. However, the R package simply uses the Java package under the hood. While using the package for my research purposes I found the R package to be computationally inefficient and hard to debug as the underlying computation happens in a completely different environment which is difficult to inspect. Therefore I have decided to reimplement the anchors package in a pure R package that is computationally efficient while also being simple to debug and diagnose.</p>
</section>
</section>
<section id="sec-anchors-from-scratch" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Anchors redesigned</h1>
<section id="sec-def-anchors" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-def-anchors"><span class="header-section-number">3.1</span> Implementing the foundation of anchors</h2>
<p>Below I have defined anchors as a set or list of predicates, while a predicate is defined as the combination of a feature name, a logical operator and a constant value to compare with. The implementation uses <code>S7</code> classes in R which is a severely new and experimental method of defining data structures in R.</p>
<section id="anchors-and-predicate" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="anchors-and-predicate"><span class="header-section-number">3.1.1</span> <code>anchors and predicate</code></h3>
<div class="cell">
<details open="">
<summary>Anchors and Predicate implementation using S7 classes</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>predicate <span class="ot">&lt;-</span> <span class="fu">new_class</span>(<span class="st">"predicate"</span>, </span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties =</span> <span class="fu">list</span>(</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">feature =</span> class_character,</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="at">operator =</span> class_function,</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">constant =</span> <span class="fu">new_union</span>(</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      class_integer, class_double, class_character</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">validator =</span> <span class="cf">function</span>(self) {</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>anchors <span class="ot">&lt;-</span> <span class="fu">new_class</span>(<span class="st">"anchors"</span>,</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties =</span> <span class="fu">list</span>(</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">predicates =</span> class_vector <span class="co"># a vector of predicate class</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="at">validator =</span> <span class="cf">function</span>(self) {</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">all</span>(<span class="fu">sapply</span>(self<span class="sc">@</span>predicates, \(x) <span class="fu">S7_inherits</span>(x, predicate)))) {</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span>(<span class="st">"The list of predicates should all inherit from the predicate class "</span>)</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In addition, there are several other functions that I have defined that work on top of anchors to be used when generating anchors as utility functions.</p>
</section>
<section id="extend" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="extend"><span class="header-section-number">3.1.2</span> <code>extend</code></h3>
<p>As we are going to be iteratively generating predicates, an anchor should be extendable by a predicate.</p>
<div class="cell">
<details open="">
<summary>extend method implementation</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>extend <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"extend"</span>, <span class="st">"x"</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param pred The predicate to extend x with</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">#' @return Extended anchor</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(extend, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, pred) {</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  x<span class="sc">@</span>predicates <span class="ot">&lt;-</span> <span class="fu">c</span>(x<span class="sc">@</span>predicates, pred)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(x)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="satisfies" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="satisfies"><span class="header-section-number">3.1.3</span> <code>satisfies</code></h3>
<p>Given a dataset the <code>satisfies</code> function tells us how many of the data points are satisfied through the boundary defined by the anchor (i.e.&nbsp;how many data points are inside the boundary)</p>
<div class="cell">
<details open="">
<summary>satisfies method implementation</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>satisfies <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"satisfies"</span>, <span class="st">"x"</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param data The dataframe to apply anchors on. Can be one instance or an entire dataset.</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">#' @return A logical vector indicating whether the anchors satisfies `data`</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(satisfies, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, data) {</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  predicate_cols <span class="ot">&lt;-</span> <span class="fu">sapply</span>(x<span class="sc">@</span>predicates, \(x) x<span class="sc">@</span>feature)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">all</span>(predicate_cols <span class="sc">%in%</span> <span class="fu">colnames</span>(data))) {</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">stop</span>(glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>      <span class="st">"Predicates contain the following columns </span><span class="sc">\n</span><span class="st"> {predicate_cols}</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      <span class="st">"that might not be in the dataset with the following columns </span><span class="sc">\n</span><span class="st"> {colnames(data)}"</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>  satis_list <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">TRUE</span>, <span class="fu">nrow</span>(data))</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (predicate <span class="cf">in</span> x<span class="sc">@</span>predicates) {</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    result_list <span class="ot">&lt;-</span> predicate<span class="sc">@</span><span class="fu">operator</span>(data[[predicate<span class="sc">@</span>feature]], predicate<span class="sc">@</span>constant)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    satis_list <span class="ot">&lt;-</span> satis_list <span class="sc">&amp;</span> result_list</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(satis_list)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="precision-1" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="precision-1"><span class="header-section-number">3.1.4</span> <code>precision</code></h3>
<p>The way precision is defined is by collecting samples from the perturbation distribution (i.e.&nbsp;the varied realities of the local instance) and then selecting the ones that are within the boundary to apply the model on top of those filtered points and calculating the proportion of class labels.</p>
<div class="cell">
<details open="">
<summary>precision method implementation</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>precision <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"precision"</span>, <span class="st">"x"</span>)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param model a predict function that will provide the predicted labels given a dataset</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="co">#' @return named vector of proportions</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(precision, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, model, dist, <span class="at">n_samples =</span> <span class="dv">100</span>) {</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  samples <span class="ot">&lt;-</span> <span class="fu">dist</span>(<span class="at">n =</span> n_samples)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  satisfying_rows <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">satisfies</span>(x, samples), <span class="at">arr.ind =</span> <span class="cn">TRUE</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">length</span>(satisfying_rows) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">message</span>(<span class="st">"No satisfying rows found in samples"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  samples <span class="ot">&lt;-</span> samples <span class="sc">|&gt;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    dplyr<span class="sc">::</span><span class="fu">slice</span>(satisfying_rows)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  preds <span class="ot">&lt;-</span> <span class="fu">model</span>(samples)</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="at">prop =</span> <span class="fu">as.vector</span>(<span class="fu">table</span>(preds) <span class="sc">/</span> <span class="fu">sum</span>(<span class="fu">table</span>(preds))))</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="coverage-1" class="level3" data-number="3.1.5">
<h3 data-number="3.1.5" class="anchored" data-anchor-id="coverage-1"><span class="header-section-number">3.1.5</span> <code>coverage</code></h3>
<p>Coverage is defined from an implementation perspective as the number of samples from the perturbation distribution that the anchor is satisfying.</p>
<div class="cell">
<details open="">
<summary>coverage method implementation</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>coverage <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"coverage"</span>, <span class="st">"x"</span>)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(coverage, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, dist, <span class="at">n_samples =</span> <span class="dv">100</span>) {</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  samples <span class="ot">&lt;-</span> <span class="fu">dist</span>(<span class="at">n =</span> n_samples)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">satisfies</span>(x, samples)))</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-prop-cover-area" class="level3" data-number="3.1.6">
<h3 data-number="3.1.6" class="anchored" data-anchor-id="sec-prop-cover-area"><span class="header-section-number">3.1.6</span> Proposal for a new coverage method</h3>
<p>However, it would be more sensible to have the coverage be defined by the area of the feature space that the anchor covers in comparison to the entire feature space. Therefore in this function I will be calculating the coverage based on the size of the bounding box compared to the entire dataset.</p>
<p><code>coverage based on feature space</code></p>
<div class="cell">
<details open="">
<summary>Coverage using area of the bounding box</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>coverage_area <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"coverage_area"</span>, <span class="st">"x"</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param dataset the dataset used to calculate the area upon</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(coverage_area, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, dataset) {</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>  little_box <span class="ot">&lt;-</span> dataset[<span class="fu">satisfies</span>(x, dataset), ]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">calculate_area</span>(little_box) <span class="sc">/</span> <span class="fu">calculate_area</span>(dataset))</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">#' @description Calculates the area of the rectangular shape that encompasses the dataset by getting the range (max - min) of each column and multiplying the value across columns</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>calculate_area <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>  data <span class="sc">|&gt;</span> <span class="fu">map_dbl</span>(<span class="sc">~</span><span class="fu">max</span>(.x, <span class="at">na.rm =</span> T) <span class="sc">-</span> <span class="fu">min</span>(.x, <span class="at">na.rm =</span> T)) <span class="sc">|&gt;</span> <span class="fu">prod</span>()</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="sec-brute-force-oned" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-brute-force-oned"><span class="header-section-number">3.2</span> Brute force approach on one dimensional data</h2>
<p>Now that we have a rough idea of what anchors are, I will begin by reproducing the concepts given in the paper. Instead of simply reproducing the final algorithm mentioned in the paper I will be emulating the thought process of constructing the final solution by developing the idea of anchors with the simplest case to more advanced complex scenarios. Throughout this report I will be using random forest models as an example black box models for simplicity and ease of implementation.</p>
<p>Let’s explore the idea of anchors with a simple one dimensional example. First I generate data in the range of <span class="math inline">\([0,1]\)</span> and assign a binary class based on the following criteria.</p>
<p><span class="math display">\[
\begin{equation}
Y =
    \begin{cases}
        1 &amp; \text{if } \sin(15 \cdot x) &gt; 0 \\
        0 &amp; \text{if } \sin(15 \cdot x) &lt; 0
    \end{cases}
\end{equation}
\]</span></p>
<p>This dataset will be considered as the population from which I would collect a sample dataset to consider as the observed data. The observed data will then be segmented into training and testing data to develop black box models. For demonstration purposes I would be using only the training dataset to generate and test anchors on.</p>
<section id="generating-data" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="generating-data"><span class="header-section-number">3.2.1</span> Generating data</h3>
<div class="cell">
<details>
<summary>Code to generate one dimensional data</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># get the population x</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>pop_x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="at">by =</span> <span class="fl">0.01</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="co"># assign a class</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>outcome <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">sin</span>(<span class="dv">15</span> <span class="sc">*</span> pop_x) <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="st">"Plus"</span>, <span class="st">"Minus"</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>pop_data <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">x =</span> pop_x, <span class="at">class =</span> <span class="fu">factor</span>(outcome))</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize population</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>pop_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pop_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span><span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">subtitle =</span> <span class="st">"Population data for 1 dimension"</span>, <span class="at">y =</span> <span class="st">""</span>)</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co"># sample half of it</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">100</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>sample_data <span class="ot">&lt;-</span> pop_data <span class="sc">|&gt;</span> <span class="fu">slice_sample</span>(<span class="at">prop =</span> <span class="fl">0.5</span>, <span class="at">by =</span> class)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>obs_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(sample_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span><span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">subtitle =</span> <span class="st">"Observed sample data"</span>, <span class="at">y =</span> <span class="st">""</span>)</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="co"># create a training and testing set</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">200</span>)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>train_df <span class="ot">&lt;-</span> sample_data <span class="sc">|&gt;</span> <span class="fu">slice_sample</span>(<span class="at">prop =</span> <span class="fl">0.7</span>, <span class="at">by =</span> class)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>train_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(train_df, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span><span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">subtitle =</span> <span class="st">"Training data"</span>, <span class="at">y =</span> <span class="st">""</span>)</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>pop_plot <span class="sc">/</span> obs_plot <span class="sc">/</span> train_plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Afterwards I will be fitting a simple random forest model with 10 trees.</p>
<div class="cell">
<details>
<summary>Code to fit random forest model</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># fit a randomforest model</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>rfmodel <span class="ot">&lt;-</span> <span class="fu">randomForest</span>(class <span class="sc">~</span> x, <span class="at">data =</span> train_df, <span class="at">ntree =</span> <span class="dv">10</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>rfmodel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
 randomForest(formula = class ~ x, data = train_df, ntree = 10) 
               Type of random forest: classification
                     Number of trees: 10
No. of variables tried at each split: 1

        OOB estimate of  error rate: 6.25%
Confusion matrix:
      Minus Plus class.error
Minus    12    1  0.07692308
Plus      1   18  0.05263158</code></pre>
</div>
</div>
<!-- Now how do we explain the decision process of this black box model using anchors. While it is possible to explain the decision process of a randomforest model with 10 trees fitted on a 1-dimensional data, we want to start explaining the process of anchors with a simpler case of one dimensional data. -->
</section>
<section id="sec-demo-single-inst" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="sec-demo-single-inst"><span class="header-section-number">3.2.2</span> Demonstration on a single point</h3>
<p>Let us first pick a data point in the dataset. Ideally a point in a border would be best to illustrate the idea.</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>For a one dimensional example, a boundary region would be defined by two values, a value left to the given value and a value right to the given value. The values for these bounding boxes will be generated based on the midpoints between observed data points. This would ensure that I will not be generating bounding boxes in areas that are not plausible for the original dataset.</p>
<div class="cell">
<details>
<summary>Code to generate cutpoints</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>x_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"x"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>x_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(x_vals[<span class="sc">-</span><span class="fu">length</span>(x_vals)], x_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>x_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>x],</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>x]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> <span class="fu">rename</span>(<span class="at">a =</span> Var1, <span class="at">b =</span> Var2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Let’s visualize how a few bounding boxes should look like,</p>
<div class="cell">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> x_grid <span class="sc">|&gt;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>      <span class="fu">slice_sample</span>(<span class="at">n =</span> <span class="dv">3</span>) <span class="sc">|&gt;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">id =</span> <span class="fu">row_number</span>()),</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>, <span class="at">color =</span> <span class="fu">factor</span>(id)),</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span> </span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Sample bounding boxes"</span>, <span class="at">color =</span> <span class="st">"Bounding box ID"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>For a one dimensional example the simplest solution would be to apply a brute force approach and calculate the precision and coverage for all the possible bounding boxes. Notice that since I am starting off with boundaries that already contain the point and extending forward <strong>I am changing the algorithm from the bottom up approach as mentioned in the paper to a top down approach in the upcoming sections</strong>. In order to calculate the precision and coverage I would need to define the model function <span class="math inline">\(f\)</span> and the perturbation distribution <span class="math inline">\(D\)</span>. For this specific case, the perturbation distribution would be giving out all the possible values for the one dimension which would be the same set of values used in the population data i.e.&nbsp;<span class="math inline">\([0.01,0.02, \dots, 0.99, 1.00]\)</span>.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>model_func <span class="ot">&lt;-</span> <span class="cf">function</span>(data_samples) {</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">predict</span>(rfmodel, data_samples))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>dist_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="at">by =</span> <span class="fl">0.01</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="brute-force-approach" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="brute-force-approach"><span class="header-section-number">3.2.3</span> Brute force approach</h3>
<div class="cell">
<details>
<summary>Code for brute force approach</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> x_grid <span class="sc">|&gt;</span> <span class="fu">apply</span>(<span class="dv">1</span>, <span class="cf">function</span>(row) {</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"a"</span>]),</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"b"</span>])</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  cover <span class="ot">&lt;-</span> <span class="fu">coverage</span>(bound, dist_func, <span class="at">n_samples =</span> <span class="dv">500</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  cover_area <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x))</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">500</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">cover =</span> cover, <span class="at">cover_area =</span> cover_area, <span class="at">prec =</span> prec))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>There is an interesting pattern of the coverage and precision in the above plot. The coverage of high precision bounding boxes would be quite low which relates well to the real world scenario where smaller boundary boxes would be quite precise while larger boundary boxes would be having moderate precision.</p>
<p>Once the brute force approach is applied I have the precision and coverage for all the bounding boxes. If I inspect the relationship between the precision and coverage it would be easier for us to identify which bounding box to select.</p>
<div class="cell">
<details>
<summary>Visualizing the relationship between precision and coverage</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>res_df <span class="ot">&lt;-</span> res <span class="sc">|&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dfr</span>(<span class="sc">~</span> <span class="fu">tibble</span>(</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>      <span class="at">cover =</span> .x<span class="sc">$</span>cover,</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      <span class="at">cover_area =</span> .x<span class="sc">$</span>cover_area,</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_1 =</span> .x<span class="sc">$</span>prec[<span class="dv">1</span>],</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_2 =</span> .x<span class="sc">$</span>prec[<span class="dv">2</span>])</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>res_df <span class="sc">|&gt;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> prec_1, <span class="at">y =</span> cover_area)) <span class="sc">+</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for all possible bounding boxes in 1 dimension"</span>,</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Let us visualize the bounding box with the highest precision on both the population data and the training data.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>max_prec_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_max</span>(prec_1)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>max_prec_train_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>,</span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>),</span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are training data"</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>max_prec_pop_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  pop_data,</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>,</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>),</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span>)</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>max_prec_pop_plot <span class="sc">/</span> max_prec_train_plot </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>The most optimal bounding box would be the one that has high coverage while having precision above a threshold (in this case 0.8). The most optimal bounding box would look like the following.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>optimal_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(cover), <span class="fu">desc</span>(prec_1)) <span class="sc">|&gt;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(prec_1 <span class="sc">&gt;</span> <span class="fl">0.8</span>) <span class="sc">|&gt;</span> </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="dv">1</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>optimal_bound_train_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>,</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>),</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are training data points"</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>optimal_bound_pop_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  pop_data,</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span> </span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>,</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span></span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>),</span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span></span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a>optimal_bound_pop_plot <span class="sc">/</span> optimal_bound_train_plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-20-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="redemonstration-for-robustness" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="redemonstration-for-robustness"><span class="header-section-number">3.2.4</span> Redemonstration for robustness</h3>
<p>Now let’s attempt the above for a different point and see how the bounding box changes.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> <span class="dv">6</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-21-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>I will need to generate a new set of possible bounding boxes that surround the new instance of interest. After generating these bounding boxes I can calculate the precision and accuracy for each of these bounding boxes and obtain the bounding box with the highest precision and the most optimal bounding box.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>x_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"x"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>x_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(x_vals[<span class="sc">-</span><span class="fu">length</span>(x_vals)], x_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>x_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>x],</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>x]</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> <span class="fu">rename</span>(<span class="at">a =</span> Var1, <span class="at">b =</span> Var2)</span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> x_grid <span class="sc">|&gt;</span> <span class="fu">apply</span>(<span class="dv">1</span>, <span class="cf">function</span>(row) {</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a>  bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"a"</span>]),</span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"b"</span>])</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cover &lt;- coverage(bound, dist_func, n_samples = 500)</span></span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>  cover <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, <span class="at">dataset =</span> train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x))</span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a>  prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">500</span>)</span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">cover =</span> cover, <span class="at">prec =</span> prec))</span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a>res_df <span class="ot">&lt;-</span> res <span class="sc">|&gt;</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dfr</span>(<span class="sc">~</span> <span class="fu">tibble</span>(</span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a>      <span class="at">cover =</span> .x<span class="sc">$</span>cover,</span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_1 =</span> .x<span class="sc">$</span>prec[<span class="dv">1</span>],</span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_2 =</span> .x<span class="sc">$</span>prec[<span class="dv">2</span>])</span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a>res_df <span class="sc">|&gt;</span></span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> prec_1, <span class="at">y =</span> cover)) <span class="sc">+</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for all possible bounding boxes in 1 dimension"</span>,</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a>  )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-22-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>max_prec_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_max</span>(prec_1) <span class="sc">|&gt;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># since there are more than one box with highest precision we will be selecting the bounding box we will be selecting a bounding box at random</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_sample</span>(<span class="at">n =</span> <span class="dv">1</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>max_prec_train_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(train_df[<span class="sc">-</span>local_instance, ], <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are training data"</span>)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>max_prec_pop_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pop_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span>)</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>optimal_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(cover), <span class="fu">desc</span>(prec_1)) <span class="sc">|&gt;</span></span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(prec_1 <span class="sc">&gt;</span> <span class="fl">0.8</span>) <span class="sc">|&gt;</span> </span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="dv">1</span>)</span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>optimal_bound_train_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(train_df[<span class="sc">-</span>local_instance, ], <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are training data points"</span>)</span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>optimal_bound_pop_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pop_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb22-53"><a href="#cb22-53" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb22-54"><a href="#cb22-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb22-55"><a href="#cb22-55" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb22-56"><a href="#cb22-56" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb22-57"><a href="#cb22-57" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb22-58"><a href="#cb22-58" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb22-59"><a href="#cb22-59" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb22-60"><a href="#cb22-60" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb22-61"><a href="#cb22-61" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb22-62"><a href="#cb22-62" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb22-63"><a href="#cb22-63" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span>)</span>
<span id="cb22-64"><a href="#cb22-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-65"><a href="#cb22-65" aria-hidden="true" tabindex="-1"></a>(max_prec_train_plot <span class="sc">/</span> optimal_bound_train_plot) <span class="sc">|</span> (max_prec_train_plot_alt <span class="sc">/</span> optimal_bound_train_plot_alt)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-23-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In the above plot, the left hand side is the previous point while the right hand side is the alternative point. Optimizing for coverage has been proven to be slightly useful in giving a broader scope of the model boundary. Based on both these points and their decision rules, a user should be able to identify what the model boundary would look like through anchors. In this example, the user would know that most of the Minus points are to the left of the given point (left plot) while most of the Plus points are to the right of the given point (right plot).</p>
</section>
</section>
<section id="remarks-on-brute-force-approach" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="remarks-on-brute-force-approach"><span class="header-section-number">3.3</span> Remarks on brute force approach</h2>
<p>The brute force approach is the simplest solution to get the exact solution for all of the possible bounding boxes. While it is practically rare to meet models with one variable which can not be explained through interpretable models this approach can be extended to two or higher dimensions to explore all the possible bounding boxes in a greedy manner.</p>
</section>
<section id="sec-seq-greedy" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="sec-seq-greedy"><span class="header-section-number">3.4</span> Sequential Greedy Approach in two dimensions</h2>
<p>I am going to use the previous brute force approach sequentially across dimensions using the following two dimensional dataset.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>w <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"wiggly.csv"</span>,</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>              <span class="at">col_select =</span> <span class="sc">-</span><span class="dv">1</span>,</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">col_types =</span> <span class="fu">cols</span>(</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                <span class="at">x =</span> <span class="fu">col_double</span>(),</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>                <span class="at">y =</span> <span class="fu">col_double</span>(),</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                <span class="at">class =</span> <span class="fu">col_double</span>())) <span class="sc">|&gt;</span> </span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">class =</span> <span class="fu">factor</span>(<span class="fu">ifelse</span>(class <span class="sc">==</span> <span class="dv">3</span>, <span class="st">"Positive"</span>, <span class="st">"Negative"</span>)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stderr">
<pre><code>New names:
• `` -&gt; `...1`</code></pre>
</div>
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>observed_2dim_plot <span class="ot">&lt;-</span> w <span class="sc">|&gt;</span> </span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Observed data for 2 dimensions"</span>) <span class="sc">+</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_equal</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Similar to the previous case I would be sampling a set fraction of data points to build the training dataset and fit a random forest model on top of it.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sample train data</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">69420</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>train_indices <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(w), <span class="fu">round</span>(<span class="fu">nrow</span>(w) <span class="sc">*</span> <span class="fl">0.8</span>))</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>train_2dim_plot <span class="ot">&lt;-</span> w[train_indices, ] <span class="sc">|&gt;</span> </span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Training data"</span>) <span class="sc">+</span> </span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_equal</span>()</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>train_2dim_plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-25-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>train_df <span class="ot">&lt;-</span> w[train_indices, ] <span class="sc">|&gt;</span> <span class="fu">mutate</span>(<span class="at">id =</span> <span class="fu">row_number</span>())</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(randomForest)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>rfmodel <span class="ot">&lt;-</span> <span class="fu">randomForest</span>(class <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">data =</span> train_df, <span class="at">ntree =</span> <span class="dv">5</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>rfmodel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
 randomForest(formula = class ~ x + y, data = train_df, ntree = 5) 
               Type of random forest: classification
                     Number of trees: 5
No. of variables tried at each split: 1

        OOB estimate of  error rate: 10.96%
Confusion matrix:
         Negative Positive class.error
Negative       75        7  0.08536585
Positive        9       55  0.14062500</code></pre>
</div>
</div>
<p>When selecting instances I will be selecting instances that the model is having difficulty predicting. These points are most likely situated in the boundary area and therefore would be ideal candidates for exploring how anchors work.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># select instance</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>prob_matrix <span class="ot">&lt;-</span> <span class="fu">predict</span>(rfmodel, <span class="at">newdata =</span> train_df, <span class="at">type =</span> <span class="st">"prob"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">id =</span> <span class="fu">row_number</span>())</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> prob_matrix[prob_matrix<span class="sc">$</span>Negative <span class="sc">==</span> <span class="fl">0.4</span>, <span class="st">"id"</span>]</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> local_instance[<span class="dv">1</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>train_df[<span class="sc">-</span>local_instance, ] <span class="sc">|&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">size =</span> <span class="dv">5</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.05</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-28-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>Similar to the brute force approach I would want to generate bounding boxes in the 2 dimensional space. A bounding box would consist of lower bound and an upper bound in both x and y dimensions.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># generate cutpoints</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>x_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"x"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>x_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(x_vals[<span class="sc">-</span><span class="fu">length</span>(x_vals)], x_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>x_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>x],</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>x]</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">L =</span> Var1, <span class="at">U =</span> Var2)<span class="sc">|&gt;</span> </span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">|&gt;</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(L), U)</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a>y_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"y"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>y_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(y_vals[<span class="sc">-</span><span class="fu">length</span>(y_vals)], y_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>y_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>  y_cutpoints[y_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>y],</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>  y_cutpoints[y_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>y]</span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">L =</span> Var1, <span class="at">U =</span> Var2) <span class="sc">|&gt;</span> </span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">|&gt;</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(L), U)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>A model function and perturbation distribution would need to be defined to evaluate the coverage and the precision of this task. In this case, the perturbation distribution would be giving out the first <span class="math inline">\(n\)</span> realization from <span class="math inline">\(X_1, X_2, \dots, X_{10000}\)</span> where <span class="math inline">\(X_i \sim \mathcal{N}_2(\underline{\mathbf{0}}, \mathbf{I})\)</span></p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>pertub_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) {</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  mulgar<span class="sc">::</span><span class="fu">rmvn</span>(<span class="at">n =</span> n, </span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>               <span class="at">p =</span> <span class="dv">2</span>,</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>               <span class="at">mn =</span> train_df[local_instance, <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)] <span class="sc">|&gt;</span> </span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">unlist</span>(),</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>               <span class="at">vc =</span> <span class="fu">cov</span>(train_df[,<span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)])</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rename</span>(<span class="at">x =</span> x1, <span class="at">y =</span> x2)</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>model_func <span class="ot">&lt;-</span> <span class="cf">function</span>(data_samples) {</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">suppressPackageStartupMessages</span>(<span class="fu">library</span>(randomForest)) <span class="co"># for future package</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">predict</span>(rfmodel, data_samples))</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">pertub_func</span>(<span class="at">n =</span> <span class="dv">10000</span>)</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>dist_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) samples[<span class="dv">1</span><span class="sc">:</span>n, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The sequentially greedy approach will first try to optimize the bounding box on one dimension in this case the <span class="math inline">\(x\)</span> dimension. Once an ideal bounding region for one dimension has been found it will then fix the boundary in that dimension and optimize the bounding box for another dimension. In this scenario, I will be optimizing for higher precision as the coverage will be increased as the bounding box increases.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># define final anchor to be null</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>final_anchor <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>dimensions <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"x"</span> <span class="ot">=</span> x_grid,<span class="st">"y"</span> <span class="ot">=</span> y_grid) <span class="co"># variable names as names</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">imap</span>(dimensions, <span class="cf">function</span>(bounds, var_name){</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>  dim_results <span class="ot">&lt;-</span> <span class="fu">future_map_dfr</span>(<span class="fu">seq_len</span>(<span class="fu">nrow</span>(bounds)), <span class="cf">function</span>(i) {</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    row <span class="ot">&lt;-</span> bounds[i, ]</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>    lower_bound_pred <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>, <span class="at">constant =</span> row[[<span class="st">"L"</span>]])</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>    upper_bound_pred <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>, <span class="at">constant =</span> row[[<span class="st">"U"</span>]])</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">is.null</span>(final_anchor)) {</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>      bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(lower_bound_pred, upper_bound_pred))  </span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>      bound <span class="ot">&lt;-</span> final_anchor <span class="sc">|&gt;</span></span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(lower_bound_pred) <span class="sc">|&gt;</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(upper_bound_pred)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># cover &lt;- coverage(bound, dist_func, n_samples = 10000)</span></span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>    cover <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x, y))</span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>    prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">10000</span>)</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>    <span class="fu">bind_cols</span>(row, <span class="fu">tibble</span>(<span class="at">cover =</span> cover, <span class="at">precision_1 =</span> prec[<span class="dv">1</span>], <span class="at">precision_2 =</span> prec[<span class="dv">2</span>]))</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>  }, <span class="at">.options =</span> <span class="fu">furrr_options</span>(<span class="at">globals =</span> <span class="fu">c</span>(<span class="st">"satisfies"</span>, <span class="st">"predicate"</span>, <span class="st">"anchors"</span>, <span class="st">"coverage_area"</span>, <span class="st">"precision"</span>, <span class="st">"extend"</span>, <span class="st">"final_anchor"</span>, <span class="st">"dist_func"</span>, <span class="st">"model_func"</span>, <span class="st">"dimensions"</span>, <span class="st">"samples"</span>, <span class="st">"rfmodel"</span>, <span class="st">"bind_cols"</span>, <span class="st">"train_df"</span>, <span class="st">"calculate_area"</span>)))</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a>  max_prec <span class="ot">&lt;-</span> dim_results <span class="sc">|&gt;</span> <span class="fu">slice_max</span>(precision_1) <span class="sc">|&gt;</span> <span class="fu">head</span>(<span class="dv">1</span>)</span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>  best_lower_bound <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>, <span class="at">constant =</span> max_prec[[<span class="st">"L"</span>]])</span>
<span id="cb33-23"><a href="#cb33-23" aria-hidden="true" tabindex="-1"></a>  best_upper_bound <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>, <span class="at">constant =</span> max_prec[[<span class="st">"U"</span>]])</span>
<span id="cb33-24"><a href="#cb33-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(final_anchor)) {</span>
<span id="cb33-25"><a href="#cb33-25" aria-hidden="true" tabindex="-1"></a>    final_anchor <span class="ot">&lt;&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(best_lower_bound, best_upper_bound))  </span>
<span id="cb33-26"><a href="#cb33-26" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb33-27"><a href="#cb33-27" aria-hidden="true" tabindex="-1"></a>    final_anchor <span class="ot">&lt;&lt;-</span> final_anchor <span class="sc">|&gt;</span></span>
<span id="cb33-28"><a href="#cb33-28" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(best_lower_bound) <span class="sc">|&gt;</span></span>
<span id="cb33-29"><a href="#cb33-29" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(best_upper_bound)</span>
<span id="cb33-30"><a href="#cb33-30" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb33-31"><a href="#cb33-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list</span>(<span class="at">res =</span> dim_results, <span class="at">lb =</span> best_lower_bound, <span class="at">ub =</span> best_upper_bound)</span>
<span id="cb33-32"><a href="#cb33-32" aria-hidden="true" tabindex="-1"></a>})</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The coverage and precision plots for the x and y dimensions are visualized below.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>x_cov_prec_plot <span class="ot">&lt;-</span> results<span class="sc">$</span>x<span class="sc">$</span>res <span class="sc">|&gt;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> precision_1, <span class="at">y =</span> cover)) <span class="sc">+</span> </span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">alpha =</span> <span class="fl">0.75</span>) <span class="sc">+</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for the x axis"</span>,</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>y_cov_prec_plot <span class="ot">&lt;-</span> results<span class="sc">$</span>y<span class="sc">$</span>res <span class="sc">|&gt;</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> precision_1, <span class="at">y =</span> cover)) <span class="sc">+</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">alpha =</span> <span class="fl">0.75</span>) <span class="sc">+</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for the y axis"</span>,</span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true" tabindex="-1"></a>x_cov_prec_plot <span class="sc">|</span> y_cov_prec_plot</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-31-1.png" class="img-fluid" width="672"></p>
</div>
</div>
<p>In the above plot there is a similar pattern to the one dimensional example of cascading points. Interestingly, precision are coverage have a non linear positive relationship in the bounding boxes in the <span class="math inline">\(x\)</span> axis. After fixing the <span class="math inline">\(x\)</span> axis, changing the <span class="math inline">\(y\)</span> axis bounding box creates a non linear negative relationship between precision and coverage. This can also provide insights into how the model boundary is defined around the local instance.</p>
<p>The bounding box with the highest precision is as follows.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>train_df[<span class="sc">-</span>local_instance, ] <span class="sc">|&gt;</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">size =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.05</span>) <span class="sc">+</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(<span class="at">inherit.aes =</span> F, </span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>            <span class="at">data =</span> <span class="fu">tibble</span>(<span class="at">x_lb =</span> results<span class="sc">$</span>x<span class="sc">$</span>lb<span class="sc">@</span>constant,</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>                          <span class="at">y_lb =</span> results<span class="sc">$</span>y<span class="sc">$</span>lb<span class="sc">@</span>constant,</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>                          <span class="at">x_ub =</span> results<span class="sc">$</span>x<span class="sc">$</span>ub<span class="sc">@</span>constant,</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>                          <span class="at">y_ub =</span> results<span class="sc">$</span>y<span class="sc">$</span>ub<span class="sc">@</span>constant),</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>            <span class="fu">aes</span>(<span class="at">xmin =</span> x_lb, <span class="at">xmax =</span> x_ub, <span class="at">ymin =</span> y_lb, <span class="at">ymax =</span> y_ub), <span class="at">fill =</span> <span class="st">"transparent"</span>, <span class="at">color =</span> <span class="st">"black"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output-display">
<p><img src="assignment_report_files/figure-html/unnamed-chunk-32-1.png" class="img-fluid" width="672"></p>
</div>
</div>
</section>
<section id="remarks-on-sequential-brute-force-approach" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="remarks-on-sequential-brute-force-approach"><span class="header-section-number">3.5</span> Remarks on sequential brute force approach</h2>
<p>The sequential brute force approach has proven to be effective in deriving an ideal bounding box. However, it is quite time consuming and might not generalize well for higher dimensions. An alternate approach would be to sample bounding boxes along each dimension and sequentially plot the precision and coverage for select points to glean insights into the model boundary around the given instance.</p>
</section>
<section id="sec-mab-twod" class="level2" data-number="3.6">
<h2 data-number="3.6" class="anchored" data-anchor-id="sec-mab-twod"><span class="header-section-number">3.6</span> Simple Multi-arm Bandits solution using Upper Confidence Bounds in two dimensions</h2>
<p>The sequential greedy method does seem to be generating good boundaries. However, to be faithful to the original paper, and to explore the benefits of using a multi-arm bandit solution, let us try modelling this as a multi-arm bandit problem. I will define the possible choices as increasing the lower or upper bound of each dimension, resulting in four arms that can be pulled. The reward in this case would be a combination of the precision and the coverage with penalties associated for taking a wrong direction.</p>
<p>To put it simply imagine you are the local point and you are trying to find similar friends like yourself by pushing a wall around you. Your options are to either push the north, east, west, or south walls to find new friends. When you increase the walls you get rewarded and when you find like minded friends you get rewarded as well.</p>
<p>We will be simulating several games and each game will have several rounds within them. The idea is to by the end of the simulation have a strategy on which actions to prioritize when generating the ideal boundary.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>envir <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  <span class="at">x_lb =</span> x_grid<span class="sc">$</span>L,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">x_ub =</span> x_grid<span class="sc">$</span>U,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="at">y_lb =</span> y_grid<span class="sc">$</span>L,</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  <span class="at">y_ub =</span> y_grid<span class="sc">$</span>U</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>actions <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"x_lb"</span>, <span class="st">"x_ub"</span>, <span class="st">"y_lb"</span>, <span class="st">"y_ub"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>In this scenario we will be using a modified Upper Confidence Bound algorithm <span class="citation" data-cites="timmiller_introduction_rl">(<a href="#ref-timmiller_introduction_rl" role="doc-biblioref">Miller n.d.</a>)</span> to find solutions to the multi-arm bandit problem</p>
<section id="sec-ucb-algo" class="level3" data-number="3.6.1">
<h3 data-number="3.6.1" class="anchored" data-anchor-id="sec-ucb-algo"><span class="header-section-number">3.6.1</span> Modified Upper Confidence Bound algorithm</h3>
<p>The reward can be defined as follows,</p>
<p><span class="math display">\[
\begin{equation}
R(\mathcal{A}) =
    \begin{cases}
        \text{Prec}(\mathcal{A}) + \text{cov}(\mathcal{A})^2 &amp; \text{if } \text{Prec}(\mathcal{A}) \in \mathbb{R} \\
        -9999 &amp; \text{if } \text{Prec}(\mathcal{A}) \notin \mathbb{R} \\
        -9999 &amp; \text{if } \text{Prec}(\mathcal{A}) &lt; 0.6
    \end{cases}
\end{equation}
\]</span></p>
<p>The reasoning for the large negative numbers is to induce a heavy penalty if the precision is not a real number (or null in this case) as there might be boundaries that would be explored which might not contain enough samples from the perturbation distribution to explore, or if the precision is a low number indicating that the model is uncertain of the results.</p>
<p>Meanwhile the next action <span class="math inline">\(a\)</span> that we select for each iteration is based on the following statement</p>
<p><span class="math display">\[
a = \underset{a}{\mathrm{argmax }} Q^*(a) + Q(a) + \sqrt{\frac{2 \cdot ln(g)}{N(a)}}
\]</span></p>
<p>Here <span class="math inline">\(N(a)\)</span> is the number of times <span class="math inline">\(a\)</span> has been selected as the next action in the course of a given game, <span class="math inline">\(Q(a)\)</span> is the cumulative average reward gain for each action in the given round, while <span class="math inline">\(Q^*(a)\)</span> is the average of <span class="math inline">\(Q(a)\)</span> across games. The terms in the square root encourages exploration by being high for actions that have been explored less – that is, when <span class="math inline">\(N(a)\)</span> is low relative to other actions while the terms with <span class="math inline">\(Q(\cdot)\)</span> encourages exploitation of known rewards. Notice that in the beginning of each round <span class="math inline">\(N(a) = 0\)</span> for all actions and therefore we would first running a few warmup rounds until we have enough values in <span class="math inline">\(N(a)\)</span> to have atleast one positive value for <span class="math inline">\(Q(a)\)</span>.</p>
<p>Also note the UCB algorithm offers a balance between exploration and exploitation which is contrastingly different from the KL-LUCB algorithm which is a pure exploration strategy. In a lower dimensional setting a pure exploration method would be no different from a brute force approach and therefore I believe for this explanation to be more intuitive we should be incorporating knowledge between games and exploiting known successful solutions.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>get_reward <span class="ot">&lt;-</span> <span class="cf">function</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func, <span class="at">class_ind =</span> <span class="dv">1</span>) {</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>x_lb[x_lb_ind]),</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>x_ub[x_ub_ind]),</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"y"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>y_lb[y_lb_ind]),</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"y"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>y_ub[y_ub_ind])</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cover &lt;- coverage(bound, dist_func, n_samples = 10000)</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  cover <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x, y))</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">10000</span>)</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(prec)) <span class="fu">return</span>(<span class="sc">-</span><span class="dv">9999</span>) <span class="co"># penalty</span></span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(prec[class_ind] <span class="sc">&lt;</span> <span class="fl">0.6</span>) {</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="sc">-</span><span class="dv">9999</span>) <span class="co"># penalty for wrong direction</span></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"reward precision {round(prec[class_ind], 2)} and coverage {round(cover, 2)}"</span>))</span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(prec[class_ind] <span class="sc">+</span> (cover <span class="sc">^</span> <span class="dv">2</span>))</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a>select_action <span class="ot">&lt;-</span> <span class="cf">function</span>(Q, N, n_game) {</span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a>  rewards <span class="ot">&lt;-</span> <span class="fu">map_dbl</span>(actions, <span class="cf">function</span>(a){</span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>    Q_star[[a]] <span class="sc">+</span> Q[[a]] <span class="sc">+</span> <span class="fu">sqrt</span>((<span class="dv">2</span> <span class="sc">*</span> <span class="fu">log</span>(n_game)) <span class="sc">/</span> N[[a]])</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"selection criteria {paste(round(rewards,2), collapse = ',')}"</span>))</span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">sum</span>(rewards <span class="sc">==</span> <span class="fu">max</span>(rewards)) <span class="sc">&gt;</span> <span class="dv">1</span>) {</span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>    max_reward <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">which</span>(rewards <span class="sc">==</span> <span class="fu">max</span>(rewards)), <span class="dv">1</span>)</span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a>    max_reward <span class="ot">&lt;-</span> <span class="fu">which.max</span>(rewards)  </span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb37-29"><a href="#cb37-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(actions[max_reward])</span>
<span id="cb37-30"><a href="#cb37-30" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Similar to the sequential greedy approach, I will be defining a model function and perturbation distribution.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>pertub_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) {</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>  mulgar<span class="sc">::</span><span class="fu">rmvn</span>(<span class="at">n =</span> n, </span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>               <span class="at">p =</span> <span class="dv">2</span>,</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>               <span class="at">mn =</span> train_df[local_instance, <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)] <span class="sc">|&gt;</span> </span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">unlist</span>(),</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>               <span class="at">vc =</span> <span class="fu">cov</span>(train_df[,<span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)])</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rename</span>(<span class="at">x =</span> x1, <span class="at">y =</span> x2)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>model_func <span class="ot">&lt;-</span> <span class="cf">function</span>(data_samples) {</span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">suppressPackageStartupMessages</span>(<span class="fu">library</span>(randomForest)) <span class="co"># for future package</span></span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">predict</span>(rfmodel, data_samples))</span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">pertub_func</span>(<span class="at">n =</span> <span class="dv">10000</span>)</span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a>dist_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) samples[<span class="dv">1</span><span class="sc">:</span>n, ]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>I will be simulating 5 games with each game containing 100 rounds. An interesting component to the following algorithm is that if I draw an action that gives me a penalty after the warmup period I would undo that action and move on to the next round. This would further ensure that the model does not explore actions that are not beneficial for the reward.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>n_games <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>n_epochs <span class="ot">&lt;-</span> <span class="dv">100</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>Q_star <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">x_ub =</span> <span class="dv">0</span>, <span class="at">y_ub =</span> <span class="dv">0</span>, <span class="at">x_lb =</span> <span class="dv">0</span>, <span class="at">y_lb =</span> <span class="dv">0</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(game <span class="cf">in</span> <span class="fu">seq_len</span>(n_games)) {</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>  cli<span class="sc">::</span><span class="fu">cli_h1</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Starting game {game}"</span>))</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  x_ub_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>  x_lb_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>  y_ub_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>  y_lb_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">x_ub =</span> <span class="dv">0</span>, <span class="at">y_ub =</span> <span class="dv">0</span>, <span class="at">x_lb =</span> <span class="dv">0</span>, <span class="at">y_lb =</span> <span class="dv">0</span>)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>  Q <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">x_ub =</span> <span class="dv">0</span>, <span class="at">y_ub =</span> <span class="dv">0</span>, <span class="at">x_lb =</span> <span class="dv">0</span>, <span class="at">y_lb =</span> <span class="dv">0</span>)</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># initial round to explore all arms</span></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(<span class="fu">all</span>(Q <span class="sc">|&gt;</span> <span class="fu">map_lgl</span>(<span class="sc">~</span> .x <span class="sc">&lt;=</span> <span class="dv">0</span>))) {</span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(action <span class="cf">in</span> actions) {</span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_ub"</span>) x_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_ub), x_ub_ind, x_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_ub"</span>) y_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_ub), y_ub_ind, y_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_lb"</span>) x_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_lb), x_lb_ind, x_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-17"><a href="#cb40-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_lb"</span>) y_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_lb), y_lb_ind, y_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-18"><a href="#cb40-18" aria-hidden="true" tabindex="-1"></a>      reward <span class="ot">&lt;-</span> <span class="fu">get_reward</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func)</span>
<span id="cb40-19"><a href="#cb40-19" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb40-20"><a href="#cb40-20" aria-hidden="true" tabindex="-1"></a>      reward <span class="ot">&lt;-</span> <span class="fu">get_reward</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func)</span>
<span id="cb40-21"><a href="#cb40-21" aria-hidden="true" tabindex="-1"></a>      N[[action]] <span class="ot">&lt;-</span> N[[action]] <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb40-22"><a href="#cb40-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(Q[[action]] <span class="sc">&lt;=</span> <span class="dv">0</span> <span class="sc">&amp;&amp;</span> reward <span class="sc">&gt;=</span> <span class="dv">0</span>) {</span>
<span id="cb40-23"><a href="#cb40-23" aria-hidden="true" tabindex="-1"></a>        Q[[action]] <span class="ot">&lt;-</span> reward</span>
<span id="cb40-24"><a href="#cb40-24" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span> {</span>
<span id="cb40-25"><a href="#cb40-25" aria-hidden="true" tabindex="-1"></a>        Q[[action]] <span class="ot">&lt;-</span> Q[[action]] <span class="sc">+</span> ((reward <span class="sc">-</span> Q[[action]]) <span class="sc">/</span> N[[action]])  </span>
<span id="cb40-26"><a href="#cb40-26" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb40-27"><a href="#cb40-27" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Q : {paste(Q, collapse = ',')} N: {paste(N, collapse = ',')}"</span>))</span>
<span id="cb40-28"><a href="#cb40-28" aria-hidden="true" tabindex="-1"></a>    }  </span>
<span id="cb40-29"><a href="#cb40-29" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb40-30"><a href="#cb40-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb40-31"><a href="#cb40-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(epoch <span class="cf">in</span> <span class="fu">seq_len</span>(n_epochs)) {</span>
<span id="cb40-32"><a href="#cb40-32" aria-hidden="true" tabindex="-1"></a>    cli<span class="sc">::</span><span class="fu">cli_h2</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Starting epoch {epoch}"</span>))</span>
<span id="cb40-33"><a href="#cb40-33" aria-hidden="true" tabindex="-1"></a>    action <span class="ot">&lt;-</span> <span class="fu">select_action</span>(Q, N, game)</span>
<span id="cb40-34"><a href="#cb40-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-35"><a href="#cb40-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_ub"</span>) x_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_ub), x_ub_ind, x_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-36"><a href="#cb40-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_ub"</span>) y_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_ub), y_ub_ind, y_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-37"><a href="#cb40-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_lb"</span>) x_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_lb), x_lb_ind, x_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-38"><a href="#cb40-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_lb"</span>) y_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_lb), y_lb_ind, y_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb40-39"><a href="#cb40-39" aria-hidden="true" tabindex="-1"></a>    reward <span class="ot">&lt;-</span> <span class="fu">get_reward</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func)</span>
<span id="cb40-40"><a href="#cb40-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-41"><a href="#cb40-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(reward <span class="sc">&lt;</span> <span class="dv">0</span>) {</span>
<span id="cb40-42"><a href="#cb40-42" aria-hidden="true" tabindex="-1"></a>      <span class="co"># if a penalty was received </span></span>
<span id="cb40-43"><a href="#cb40-43" aria-hidden="true" tabindex="-1"></a>      <span class="co"># we undo the action and go on with the rest</span></span>
<span id="cb40-44"><a href="#cb40-44" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_ub"</span>) x_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_ub_ind <span class="sc">==</span> <span class="dv">1</span>, x_ub_ind, x_ub_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb40-45"><a href="#cb40-45" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_ub"</span>) y_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_ub_ind <span class="sc">==</span> <span class="dv">1</span>, y_ub_ind, y_ub_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb40-46"><a href="#cb40-46" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_lb"</span>) x_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_lb_ind <span class="sc">==</span> <span class="dv">1</span>, x_lb_ind, x_lb_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb40-47"><a href="#cb40-47" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_lb"</span>) y_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_lb_ind <span class="sc">==</span> <span class="dv">1</span>, y_lb_ind, y_lb_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb40-48"><a href="#cb40-48" aria-hidden="true" tabindex="-1"></a>      <span class="cf">next</span></span>
<span id="cb40-49"><a href="#cb40-49" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb40-50"><a href="#cb40-50" aria-hidden="true" tabindex="-1"></a>    N[[action]] <span class="ot">&lt;-</span> N[[action]] <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb40-51"><a href="#cb40-51" aria-hidden="true" tabindex="-1"></a>    Q[[action]] <span class="ot">&lt;-</span> Q[[action]] <span class="sc">+</span> ((reward <span class="sc">-</span> Q[[action]]) <span class="sc">/</span> N[[action]])</span>
<span id="cb40-52"><a href="#cb40-52" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Q : {paste(Q, collapse = ',')} N: {paste(N, collapse = ',')}"</span>))</span>
<span id="cb40-53"><a href="#cb40-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(epoch <span class="sc">%%</span> <span class="dv">10</span> <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb40-54"><a href="#cb40-54" aria-hidden="true" tabindex="-1"></a>      state_plot <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance, ] <span class="sc">|&gt;</span></span>
<span id="cb40-55"><a href="#cb40-55" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb40-56"><a href="#cb40-56" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb40-57"><a href="#cb40-57" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">size =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb40-58"><a href="#cb40-58" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.05</span>) <span class="sc">+</span></span>
<span id="cb40-59"><a href="#cb40-59" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_rect</span>(<span class="at">inherit.aes =</span> F,</span>
<span id="cb40-60"><a href="#cb40-60" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> <span class="fu">tibble</span>(<span class="at">x_lb =</span> envir<span class="sc">$</span>x_lb[x_lb_ind],</span>
<span id="cb40-61"><a href="#cb40-61" aria-hidden="true" tabindex="-1"></a>                                <span class="at">y_lb =</span> envir<span class="sc">$</span>y_lb[y_lb_ind],</span>
<span id="cb40-62"><a href="#cb40-62" aria-hidden="true" tabindex="-1"></a>                                <span class="at">x_ub =</span> envir<span class="sc">$</span>x_ub[x_ub_ind],</span>
<span id="cb40-63"><a href="#cb40-63" aria-hidden="true" tabindex="-1"></a>                                <span class="at">y_ub =</span> envir<span class="sc">$</span>y_ub[y_ub_ind]),</span>
<span id="cb40-64"><a href="#cb40-64" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">aes</span>(<span class="at">xmin =</span> x_lb, <span class="at">xmax =</span> x_ub, <span class="at">ymin =</span> y_lb, <span class="at">ymax =</span> y_ub), <span class="at">fill =</span> <span class="st">"transparent"</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb40-65"><a href="#cb40-65" aria-hidden="true" tabindex="-1"></a>        <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Game: {game}, round: {epoch}, reward: {reward}"</span>))</span>
<span id="cb40-66"><a href="#cb40-66" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggsave</span>(<span class="at">plot =</span> state_plot,</span>
<span id="cb40-67"><a href="#cb40-67" aria-hidden="true" tabindex="-1"></a>             <span class="at">filename =</span> here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_dump_1/"</span>, glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"{game}_{epoch}.png"</span>)),</span>
<span id="cb40-68"><a href="#cb40-68" aria-hidden="true" tabindex="-1"></a>             <span class="at">device =</span> <span class="st">"png"</span>, <span class="at">bg =</span> <span class="st">"white"</span>, <span class="at">width =</span> <span class="dv">11</span>, <span class="at">height =</span> <span class="dv">8</span>, <span class="at">units =</span> <span class="st">"in"</span>)</span>
<span id="cb40-69"><a href="#cb40-69" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb40-70"><a href="#cb40-70" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb40-71"><a href="#cb40-71" aria-hidden="true" tabindex="-1"></a>  Q_star <span class="ot">&lt;&lt;-</span> <span class="fu">imap</span>(Q, <span class="cf">function</span>(val, name) {(Q_star[[name]] <span class="sc">+</span> val) <span class="sc">/</span> n_games})</span>
<span id="cb40-72"><a href="#cb40-72" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The results of the simulations are given in the following animation. Notice that after a certain rounds of games the algorithm begins to follow the same pattern many times indicating that it has settled to a local optima and therefore would be following that procedure.</p>
<div class="cell">
<details open="">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(<span class="sc">!</span><span class="fu">file.exists</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_1.gif"</span>))){</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>  gifski<span class="sc">::</span><span class="fu">gifski</span>(</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    <span class="at">png_files =</span> <span class="fu">list.files</span>(</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>      here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_dump_1/"</span>),</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>      <span class="at">full.names =</span> <span class="cn">TRUE</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">|&gt;</span> gtools<span class="sc">::</span><span class="fu">mixedsort</span>(),</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    <span class="at">gif_file =</span> here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_1.gif"</span>),</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>    <span class="at">width =</span> <span class="dv">640</span>, <span class="at">height =</span> <span class="dv">480</span>,</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">delay =</span> <span class="fl">0.25</span>, <span class="at">loop =</span> <span class="cn">TRUE</span>, <span class="at">progress =</span> <span class="cn">TRUE</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p><img src="assignment_state_plot_1.gif" class="img-fluid"></p>
</section>
</section>
<section id="remarks-on-the-multi-arm-bandit-approach" class="level2" data-number="3.7">
<h2 data-number="3.7" class="anchored" data-anchor-id="remarks-on-the-multi-arm-bandit-approach"><span class="header-section-number">3.7</span> Remarks on the Multi-arm bandit approach</h2>
<p>Compared to the sequentially greedy approach, the multi-arm bandit approach can be computationally less expensive but there is a higher risk of settling in a local optima. However as the number of dimensions <span class="math inline">\(d\)</span> increases the number of actions grows to <span class="math inline">\(d^2\)</span> meaning that there will be large search space for the multi-arm bandit solution to explore and exploit. This is where I believe a pure exploration method combined with a beam search would be beneficial to ensure that a local optima is reached.</p>
</section>
</section>
<section id="sec-review" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Discussion and Review</h1>
<section id="remarks-on-the-original-paper" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="remarks-on-the-original-paper"><span class="header-section-number">4.1</span> Remarks on the original paper</h2>
<p>The concept of anchors is an interesting approach to the topic of providing local explanations of black box models. Using human comprehensible decision rules defined as bounding boxes (a list of predicates) to explain the model’s decision process around the local instance makes it easier for humans to build trust with black box models. Anchors also gives the user the ability to predict the model behaviour for unseen instances thereby being able to extract new insights from models built on top of complex data.</p>
<p>However, the approach taken to achieve this task seems to be, in my personal opinion, unnecessarily complicated to accommodate a wide range of tasks. The reasoning behind such a stance is that exploring a finite set of possible bounding boxes in a high dimensional space while being computationally efficient should not require iterative solutions that do not guarantee optimal solutions. The usage of perturbation distributions has been a limitation in previous methods, as it restricts the method of generating samples to a particular distribution which might not be similar to the data generating distribution.</p>
</section>
<section id="discussion-on-reproducing-approach" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="discussion-on-reproducing-approach"><span class="header-section-number">4.2</span> Discussion on reproducing approach</h2>
<p>In terms of the attempt to simplify the implementation of anchors, this report provides an intuition behind the thinking process of the existing paper.</p>
<p>In addition to demystifying anchors, I have also brought in the following propositions / changes to the existing approach in this report</p>
<ol type="1">
<li>Using the area covered within the feature space to compute the coverage instead of using a perturbation distribution. (see <a href="#sec-prop-cover-area">Section&nbsp;3.1.6</a>)</li>
<li>Using a top down approach instead of a bottom up approach to building anchors. (see <a href="#sec-demo-single-inst">Section&nbsp;3.2.2</a>)</li>
<li>Using the UCB algorithm instead of the KL-LUCB algorithm to demonstrate the need for a pure exploration approach as the multi-arm bandit solution. (see <a href="#sec-ucb-algo">Section&nbsp;3.6.1</a>)</li>
<li>Providing the intuition of anchors in the following scenarios.</li>
<li>A brute force approach in one dimension (see <a href="#sec-brute-force-oned">Section&nbsp;3.2</a>)</li>
<li>A sequentially greedy approach in two dimensions (see <a href="#sec-seq-greedy">Section&nbsp;3.4</a>)</li>
<li>A multi-arm bandit approach in two dimensions (see <a href="#sec-mab-twod">Section&nbsp;3.6</a>)</li>
<li>Implementing a pure R solution using novel data structures to ease debugging and encourage understanding of how anchors work. (see <a href="#sec-def-anchors">Section&nbsp;3.1</a>)</li>
</ol>
<p>Based on the results of the report, the usage of a sequentially greedy approach has proven to be quite useful while trying to use the UCB algorithm as a balance between exploitation and exploration has proven to be detrimental. One drawback of the approach given in this document compared to the approach given in the paper is that for a dataset of <span class="math inline">\(p\)</span> variables, there will be <span class="math inline">\(2 \cdot p\)</span> decision rules which is both restrictive and hard for people to comprehend. In addition, this report is limited to tabular examples only and while it is possible to extend a similar idea to images, it would be beneficial to have decision rules built for tabular rather than images and text where the data itself requires visual explanations.</p>
<section id="software-packages-used-to-implement-anchors" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="software-packages-used-to-implement-anchors"><span class="header-section-number">4.2.1</span> Software packages used to implement anchors</h3>
<p>This report was written entirely in Quarto while the implementation was done completely on R using several R packages including <code>S7</code><span class="citation" data-cites="S7_R_pkg">(<a href="#ref-S7_R_pkg" role="doc-biblioref">Vaughan et al. 2023</a>)</span>, <code>purrr</code><span class="citation" data-cites="purrr_R_pkg">(<a href="#ref-purrr_R_pkg" role="doc-biblioref">Wickham and Henry 2023</a>)</span>, <code>dplyr</code><span class="citation" data-cites="dplyr_R_pkg">(<a href="#ref-dplyr_R_pkg" role="doc-biblioref">Wickham et al. 2023</a>)</span>, <code>ggplot2</code><span class="citation" data-cites="ggplot2_R_pkg">(<a href="#ref-ggplot2_R_pkg" role="doc-biblioref">Wickham 2016</a>)</span>.</p>
</section>
</section>
<section id="conclusions" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="conclusions"><span class="header-section-number">4.3</span> Conclusions</h2>
<p>Overall, regardless of the semantics of the implementation, based on the results of the evaluation data, anchors has performed comparatively better than LIME, another popular explainable AI method. The simplified approach is a good initiative to explain the construction of anchors to educate and encourage researchers to use anchors in their modelling pipeline. Bridging the knowledge gap in complex tools can help users identify the reasoning behind the different techniques employed by the underlying tools that they use.</p>
<!-- Simply put what I want this document to flow is to take them through the journey by first explaining 
what explainable AI is, and why it is important and what are the different variations of explainable AI

Then I will come in to talk about what anchors is and relate it to LIME and counterfactuals?

After that I will start off by fleshing my story on anchors. 

First formally define what an anchor is according to the authors. 
So to do that you will need to talk about what a predicate is and what a perturbation distribution is and what coverage and precision is. Then define the problem statement to finding anchors. and then explain how the authors have decided to find it. Give an overview of how you are going to construct anchors in an intuitive way by showcasing why the authors have decided to construct their solution in such a manner by demonstrating it for one dimensional, two dimensional data with two approaches. finally wrap up the document with an explaination of what the paper is lacking and what could be improved and where they have excelled.  -->
<!-- -->


</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-gittins_dynamic_1979" class="csl-entry" role="listitem">
Gittins, J. C., and D. M. Jones. 1979. <span>“A Dynamic Allocation Index for the Discounted Multiarmed Bandit Problem.”</span> <em>Biometrika</em> 66 (3): 561–65. <a href="https://doi.org/10.1093/biomet/66.3.561">https://doi.org/10.1093/biomet/66.3.561</a>.
</div>
<div id="ref-anchors_R_pkg" class="csl-entry" role="listitem">
Hellweg, Thorben. 2023. <em>Anchors: AnchorsOnR: High-Precision Model-Agnostic Explanations in r</em>.
</div>
<div id="ref-kl_lucb_kaufmann" class="csl-entry" role="listitem">
Kaufmann, E., and S. Kalyanakrishnan. 2013. <span>“Information Complexity in Bandit Subset Selection.”</span> <em>Journal of Machine Learning Research</em> 30 (January): 228–51.
</div>
<div id="ref-timmiller_introduction_rl" class="csl-entry" role="listitem">
Miller, T. n.d. <span>“Introduction — <span>Introduction</span> to <span>Reinforcement</span> <span>Learning</span>.”</span> Accessed October 16, 2023. <a href="https://gibberblot.github.io/rl-notes/intro.html">https://gibberblot.github.io/rl-notes/intro.html</a>.
</div>
<div id="ref-molnar_interpretable_2022" class="csl-entry" role="listitem">
Molnar, Christoph. 2022. <em>Interpretable Machine Learning: A Guide for Making Black Box Models Explainable</em>. Second edition. Munich, Germany: Christoph Molnar.
</div>
<div id="ref-molnar_interpretable_2020" class="csl-entry" role="listitem">
Molnar, Christoph, Giuseppe Casalicchio, and Bernd Bischl. 2020. <span>“Interpretable <span>Machine</span> <span>Learning</span> – <span>A</span> <span>Brief</span> <span>History</span>, <span>State</span>-of-the-<span>Art</span> and <span>Challenges</span>.”</span> In, 1323:417–31. <a href="http://arxiv.org/abs/2010.09337">http://arxiv.org/abs/2010.09337</a>.
</div>
<div id="ref-ribeiro_why_2016" class="csl-entry" role="listitem">
Ribeiro, Marco Tulio, Sameer Singh, and Carlos Guestrin. 2016. <span>“"<span>Why</span> <span>Should</span> <span>I</span> <span>Trust</span> <span>You</span>?": <span>Explaining</span> the <span>Predictions</span> of <span>Any</span> <span>Classifier</span>.”</span> <a href="https://doi.org/10.48550/ARXIV.1602.04938">https://doi.org/10.48550/ARXIV.1602.04938</a>.
</div>
<div id="ref-ribeiro_anchors:_2018" class="csl-entry" role="listitem">
———. 2018. <span>“Anchors: <span>High</span>-<span>Precision</span> <span>Model</span>-<span>Agnostic</span> <span>Explanations</span>.”</span> <em>Proceedings of the AAAI Conference on Artificial Intelligence</em> 32 (1). <a href="https://doi.org/10.1609/aaai.v32i1.11491">https://doi.org/10.1609/aaai.v32i1.11491</a>.
</div>
<div id="ref-S7_R_pkg" class="csl-entry" role="listitem">
Vaughan, Davis, Jim Hester, Tomasz Kalinowski, Will Landau, Michael Lawrence, Martin Maechler, Luke Tierney, and Hadley Wickham. 2023. <em>S7: An Object Oriented System Meant to Become a Successor to S3 and S4</em>.
</div>
<div id="ref-ggplot2_R_pkg" class="csl-entry" role="listitem">
Wickham, Hadley. 2016. <em>Ggplot2: Elegant Graphics for Data Analysis</em>. Springer-Verlag New York. <a href="https://ggplot2.tidyverse.org">https://ggplot2.tidyverse.org</a>.
</div>
<div id="ref-dplyr_R_pkg" class="csl-entry" role="listitem">
Wickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. <em>Dplyr: A Grammar of Data Manipulation</em>.
</div>
<div id="ref-purrr_R_pkg" class="csl-entry" role="listitem">
Wickham, Hadley, and Lionel Henry. 2023. <em>Purrr: Functional Programming Tools</em>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb42" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "Explaining Anchors: High precision model agnostic explanations"</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "BEX6510 Foundations of Econometrics"</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span><span class="co"> "Janith Wanniarachchi"</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="co">  html:</span></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a><span class="co">    code-tools: true</span></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: show</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a><span class="an">number-sections:</span><span class="co"> true</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a><span class="co">  eval: true</span></span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a><span class="co">  echo: true</span></span>
<span id="cb42-13"><a href="#cb42-13" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> report_bib.bib</span></span>
<span id="cb42-14"><a href="#cb42-14" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb42-15"><a href="#cb42-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-16"><a href="#cb42-16" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--</span></span>
<span id="cb42-17"><a href="#cb42-17" aria-hidden="true" tabindex="-1"></a><span class="co">The summary and presentation slides should contain an empirical verification of the main argument, whether it is a simulation study or an application based on the real data. </span></span>
<span id="cb42-18"><a href="#cb42-18" aria-hidden="true" tabindex="-1"></a><span class="co">The codes related to this exercise should be submitted along with the summary and the slides. </span></span>
<span id="cb42-19"><a href="#cb42-19" aria-hidden="true" tabindex="-1"></a><span class="co">--&gt;</span></span>
<span id="cb42-20"><a href="#cb42-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-21"><a href="#cb42-21" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--</span></span>
<span id="cb42-22"><a href="#cb42-22" aria-hidden="true" tabindex="-1"></a><span class="co">In doing so, notice the way the paper has been organised and arguments have been developed. </span></span>
<span id="cb42-23"><a href="#cb42-23" aria-hidden="true" tabindex="-1"></a><span class="co">In particular, see if you can demonstrate how every claim in the paper is backed up by evidence or proof. </span></span>
<span id="cb42-24"><a href="#cb42-24" aria-hidden="true" tabindex="-1"></a><span class="co">In addition to introducing to you some papers of high quality not only directly or indirectly related to the material that we are learning but also related to your research area, another goal is that you see the writing style and the organisation of papers that have been published in high quality journals. Last but not least, familiarise yourself with statistical software packages/tools.</span></span>
<span id="cb42-25"><a href="#cb42-25" aria-hidden="true" tabindex="-1"></a><span class="co">--&gt;</span></span>
<span id="cb42-26"><a href="#cb42-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-27"><a href="#cb42-27" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!--</span></span>
<span id="cb42-28"><a href="#cb42-28" aria-hidden="true" tabindex="-1"></a><span class="co"> There will be additional marks when a student extends, generalises and demonstrates novelty beyond the review or a straightforward implementation or extension of the paper under review.</span></span>
<span id="cb42-29"><a href="#cb42-29" aria-hidden="true" tabindex="-1"></a><span class="co">--&gt;</span></span>
<span id="cb42-30"><a href="#cb42-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-33"><a href="#cb42-33" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-34"><a href="#cb42-34" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb42-35"><a href="#cb42-35" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb42-36"><a href="#cb42-36" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb42-37"><a href="#cb42-37" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(S7)</span>
<span id="cb42-38"><a href="#cb42-38" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse) <span class="co"># getting a sword to cut a sandwich</span></span>
<span id="cb42-39"><a href="#cb42-39" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb42-40"><a href="#cb42-40" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(randomForest)</span>
<span id="cb42-41"><a href="#cb42-41" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(furrr)</span>
<span id="cb42-42"><a href="#cb42-42" aria-hidden="true" tabindex="-1"></a><span class="fu">plan</span>(multisession)</span>
<span id="cb42-43"><a href="#cb42-43" aria-hidden="true" tabindex="-1"></a><span class="fu">theme_set</span>(<span class="fu">theme_minimal</span>())</span>
<span id="cb42-44"><a href="#cb42-44" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-45"><a href="#cb42-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-46"><a href="#cb42-46" aria-hidden="true" tabindex="-1"></a><span class="fu"># From building black box models to explaining black box models</span></span>
<span id="cb42-47"><a href="#cb42-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-48"><a href="#cb42-48" aria-hidden="true" tabindex="-1"></a>Machine learning has grown from being a niche curiosity in computer science to dominating decision making processes in a variety of contexts. Thereby leading to the need to ensure that the decisions that are automated by computational systems are unbiased, accountable, and transparent. Traditionally, automated decision making was done through statistical models such as linear regression, which were inherently interpretable as models were defined based on distributional assumptions about the data and restricted the model complexity. However, these assumptions did not hold for long as began to be accumulated from many sources with higher variety, resulting in interpretable white box models failing to keep up with the desired performance. Novel machine learning models allow researchers to let the model define the functional form of the decision process. As more of our decision making processes are automated through complex models, the need to answer the question: ”How did the model arrive at this decision?” has started to gain traction over the past few years <span class="co">[</span><span class="ot">@molnar_interpretable_2020</span><span class="co">]</span>. </span>
<span id="cb42-49"><a href="#cb42-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-50"><a href="#cb42-50" aria-hidden="true" tabindex="-1"></a>Explainable AI is a research area that develops statistical and algorithmic techniques to approximate and communicate the decision process of black box models. There are many classifications of explainable AI methods, and the two most prominent classifications are centered around the model agnosticism and the scope of explanations. Explainable AI methods that are capable of explaining any black box models are called model agnostic methods where the internal parameters or gradients are not utilized to explain the model. On the other hand, there are model specific methods that utilize the structure of the black box model such as the weights and gradients of neural networks to provide explanations. In terms of the scope of explanations, an explaination can be capable of explaining the entire decision process of the entire training data instances or for a single data instance. The former would be called global explaination methods while the latter will be called local explaination methods. Examples for global explaination methods would include Partial Dependence Plots and Individual Conditional Effects while examples of local explaination methods would include LIME, SHAP and Counterfactuals <span class="co">[</span><span class="ot">@molnar_interpretable_2022</span><span class="co">]</span>.</span>
<span id="cb42-51"><a href="#cb42-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-52"><a href="#cb42-52" aria-hidden="true" tabindex="-1"></a>This report will discuss and review the paper "Anchors: High precision model agnostic explanations" <span class="co">[</span><span class="ot">@ribeiro_anchors:_2018</span><span class="co">]</span>. The structure of this report will be as follows. @sec-what-are-anchors will define what anchors are and review the main arguments given by the authors of the paper. As a contribution to the existing research work, I will be providing a tutorial on what anchors are, from a simple example to complex methods using different intuitive techniques and dicussing the applicability of each method. @sec-anchors-from-scratch will implement the fundamental concept of anchors in such incremental steps starting with one dimensional data and moving to higher dimensions. Finally, an overall review of the paper and the discussion on the process of reproducing the paper will be discussed in @sec-review.</span>
<span id="cb42-53"><a href="#cb42-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-54"><a href="#cb42-54" aria-hidden="true" tabindex="-1"></a><span class="fu"># What are Anchors? {#sec-what-are-anchors}</span></span>
<span id="cb42-55"><a href="#cb42-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-56"><a href="#cb42-56" aria-hidden="true" tabindex="-1"></a><span class="fu">## Theoretical definition</span></span>
<span id="cb42-57"><a href="#cb42-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-58"><a href="#cb42-58" aria-hidden="true" tabindex="-1"></a>Anchors are a model agnostic method of explaining black box models which attempt to present the model's decision process for a single given instance. In addition to providing the decision process for the given instance, anchors provide humans with the capability to predict a black box model's behaviour on unknown instances. This is achieved by providing a set of simple decision rules that apply to a large area of the feature space containing predictions similar to the given instance.</span>
<span id="cb42-59"><a href="#cb42-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-60"><a href="#cb42-60" aria-hidden="true" tabindex="-1"></a>The authors have defined anchors as a rule or a set of predicates that satisfy the given instance and is a sufficient condition for $f(x)$ (i.e. the model output) with high probability.</span>
<span id="cb42-61"><a href="#cb42-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-62"><a href="#cb42-62" aria-hidden="true" tabindex="-1"></a>A predicate is a logical condition that an observation may or may not satisfy. The simplest form of these predicates takes in the form of $<span class="sc">\{</span>x_1 &gt; 2<span class="sc">\}</span>$. An instance with the $x_1$ feature greater than 2 would satisfy this predicate. Therefore a possible candidate for an anchor might take the form of $\mathcal{A} = <span class="sc">\{</span>x_1 &gt; 2, x_1 &lt; 3, x_2 &gt; 10, x_3 &lt; 5,x_4 == 1, \dots<span class="sc">\}</span>$. The authors have not defined exactly how a predicate should be structured due to the wide variety of data available in the wild. Since most of our applications are on tabular data, I can assume the simplest form of orthogonal boundaries.</span>
<span id="cb42-63"><a href="#cb42-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-64"><a href="#cb42-64" aria-hidden="true" tabindex="-1"></a>For a list of predicates to be an anchor it should satisfy the given instance while also maximizing two criteria,</span>
<span id="cb42-65"><a href="#cb42-65" aria-hidden="true" tabindex="-1"></a><span class="ss">  1. </span>Precision</span>
<span id="cb42-66"><a href="#cb42-66" aria-hidden="true" tabindex="-1"></a><span class="ss">  2. </span>Coverage</span>
<span id="cb42-67"><a href="#cb42-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-68"><a href="#cb42-68" aria-hidden="true" tabindex="-1"></a>Let's dive into how each of these criteria is calculated.</span>
<span id="cb42-69"><a href="#cb42-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-70"><a href="#cb42-70" aria-hidden="true" tabindex="-1"></a><span class="fu">### Precision</span></span>
<span id="cb42-71"><a href="#cb42-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-72"><a href="#cb42-72" aria-hidden="true" tabindex="-1"></a>In the paper, precision is defined formally as </span>
<span id="cb42-73"><a href="#cb42-73" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-74"><a href="#cb42-74" aria-hidden="true" tabindex="-1"></a>\text{Prec}(\mathcal{A}) = \mathbb{E}_{\mathcal{D}(z|\mathcal{A})}[\mathbb{1}_{f(x) = f(z)}]</span>
<span id="cb42-75"><a href="#cb42-75" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-76"><a href="#cb42-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-77"><a href="#cb42-77" aria-hidden="true" tabindex="-1"></a>Here $\mathbb{D}$ is the perturbation distribution based on the given instance $x$. </span>
<span id="cb42-78"><a href="#cb42-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-79"><a href="#cb42-79" aria-hidden="true" tabindex="-1"></a><span class="fu">#### What is a perturbation distribution?</span></span>
<span id="cb42-80"><a href="#cb42-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-81"><a href="#cb42-81" aria-hidden="true" tabindex="-1"></a>A perturbation distribution is a method of generating varied versions of the data (kind of like alternate realities of the same data). The simplest form of a perturbation distribution would be to use a multivariate normal distribution centered around the given instance.</span>
<span id="cb42-82"><a href="#cb42-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-83"><a href="#cb42-83" aria-hidden="true" tabindex="-1"></a>The paper argues that it is intractable to calculate the precision directly (the term directly could be meaning analytically as it is numerically possible to approximate the expected value). Therefore a list of predicates $\mathcal{A}$ is considered an anchor if </span>
<span id="cb42-84"><a href="#cb42-84" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb42-85"><a href="#cb42-85" aria-hidden="true" tabindex="-1"></a>\text{Pr}(\text{Prec}(\mathcal{A}) \ge \tau) \ge 1 - \delta</span>
<span id="cb42-86"><a href="#cb42-86" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-87"><a href="#cb42-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-88"><a href="#cb42-88" aria-hidden="true" tabindex="-1"></a>From an implementation perspective, the precision of the anchor would then be the proportion of data points from the perturbation distribution with the same class as the given instance within the boundary of the anchor.</span>
<span id="cb42-89"><a href="#cb42-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-90"><a href="#cb42-90" aria-hidden="true" tabindex="-1"></a><span class="fu">### Coverage</span></span>
<span id="cb42-91"><a href="#cb42-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-92"><a href="#cb42-92" aria-hidden="true" tabindex="-1"></a>The paper defines the coverage of an anchor $A$ as the probability that it applies to samples from $\mathcal{D}$, $\text{cov}(\mathcal{A}) = \mathbb{E}_{\mathcal{D}(z)}<span class="co">[</span><span class="ot">\mathcal{A}(z)</span><span class="co">]</span>$. Simply put we would be calculating the proportion of samples from the perturbation distribution that satisfy the boundary of the anchor. However, this would be problematic if our perturbation distribution is dense or sparse around certain areas.</span>
<span id="cb42-93"><a href="#cb42-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-94"><a href="#cb42-94" aria-hidden="true" tabindex="-1"></a>Therefore, I would argue that picking a boundary that captures the most of the perturbation distribution is not ideal and instead, it would be best to compute the coverage based on the proportion of the feature space that is covered. This idea will be covered in detail in @sec-def-anchors.</span>
<span id="cb42-95"><a href="#cb42-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-96"><a href="#cb42-96" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- </span><span class="al">TODO</span><span class="co">: Explain the methodology that was used to build anchors. Including the construction of anchors using beam search, using multi-arm bandits and the evaluation using user studies and simulation data --&gt;</span></span>
<span id="cb42-97"><a href="#cb42-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-98"><a href="#cb42-98" aria-hidden="true" tabindex="-1"></a><span class="fu">## Problem statement</span></span>
<span id="cb42-99"><a href="#cb42-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-100"><a href="#cb42-100" aria-hidden="true" tabindex="-1"></a>Since a list of predicates is considered to be an anchor if it maximizes the coverage and precision, finding an anchor for a given instance can be defined as the solution to the following optimization problem</span>
<span id="cb42-101"><a href="#cb42-101" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-102"><a href="#cb42-102" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-103"><a href="#cb42-103" aria-hidden="true" tabindex="-1"></a>\max_{\mathcal{A} \text{ s.t. } \text{Pr}(\text{Prec}(\mathcal{A}) \ge \tau) \ge 1 - \delta} \text{cov}(\mathcal{A})</span>
<span id="cb42-104"><a href="#cb42-104" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-105"><a href="#cb42-105" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-106"><a href="#cb42-106" aria-hidden="true" tabindex="-1"></a>The target would then be to maximize the coverage while ensuring that the precision is above a tolerance level. However, as an extension of this approach, I would argue that understanding the local neighbourhood of a given instance is more important than being able to extrapolate a model's capability on unseen instances. The decision rules with large coverages are based primarily on the perturbation distribution $\mathcal{D}$ and therefore the choice of distribution can give flawed decision rules to end users who mighy only want to observe the decision rules for similar points as the given instance in the feature space.</span>
<span id="cb42-107"><a href="#cb42-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-108"><a href="#cb42-108" aria-hidden="true" tabindex="-1"></a><span class="fu">## Methodology</span></span>
<span id="cb42-109"><a href="#cb42-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-110"><a href="#cb42-110" aria-hidden="true" tabindex="-1"></a>The authors argue that while it is possible to generate a very large dataset and use methods such as Inductive Logic Programming to find these predicates, in high dimensional sparse datasets, the number of possible samples and predictions would be limited. Therefore they have decided to formulate the problem as a multi-arm bandit <span class="co">[</span><span class="ot">@gittins_dynamic_1979</span><span class="co">]</span> with the solution being a modified version of KL-LUCB combined with beam search to appropriately explore the possible candidates for anchors.</span>
<span id="cb42-111"><a href="#cb42-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-112"><a href="#cb42-112" aria-hidden="true" tabindex="-1"></a><span class="fu">### Multi-arm bandit problems</span></span>
<span id="cb42-113"><a href="#cb42-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-114"><a href="#cb42-114" aria-hidden="true" tabindex="-1"></a>Multi-arm bandit problems are a classic problem in reinforcement learning where $K$ number of choices ("arms of poker machines") are presented to an agent and each draw ("pull") from a choice gives a certain reward based on an unknown probability distribution. Some arms will give higher rewards than others. The objective is to design an agent that will maximize the average reward by the end of the sequence of draws. While trying to maximize the reward the agent will have to trade-off between either exploring the available choices or exploiting the known choices that give high rewards.</span>
<span id="cb42-115"><a href="#cb42-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-116"><a href="#cb42-116" aria-hidden="true" tabindex="-1"></a>There are different strategies used to solve these problems that attempt to balance the exploration-exploitation trade-off such as,</span>
<span id="cb42-117"><a href="#cb42-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-118"><a href="#cb42-118" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Epsilon-greedy strategy </span>
<span id="cb42-119"><a href="#cb42-119" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Softmax strategy</span>
<span id="cb42-120"><a href="#cb42-120" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Upper Confidence Bound strategy etc.</span>
<span id="cb42-121"><a href="#cb42-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-122"><a href="#cb42-122" aria-hidden="true" tabindex="-1"></a>However, in this paper, the authors have used a pure exploration method that tries to explore the possible choices as much as possible rather than exploiting the known arms.</span>
<span id="cb42-123"><a href="#cb42-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-124"><a href="#cb42-124" aria-hidden="true" tabindex="-1"></a><span class="fu">### Beam search</span></span>
<span id="cb42-125"><a href="#cb42-125" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-126"><a href="#cb42-126" aria-hidden="true" tabindex="-1"></a>Beam search is a heuristic search algorithm similar to Best First Search and Breadth First Search in the computer science field. The target of the algorithm is to find a possible goal state in a large graph in the shortest amount of time. Beam search achieves this by performing a breadth first search with a parameter $\beta$ limiting the breadth of the graph traversal and then ordering the visible nodes by a heuristic value to select which node to traverse to next. While traversing the graph, beam search will keep a pre determined number of nodes that could potentially be goal states and discard ones that are not above valuable based on a heuristic.</span>
<span id="cb42-127"><a href="#cb42-127" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-128"><a href="#cb42-128" aria-hidden="true" tabindex="-1"></a><span class="fu">### The algorithm</span></span>
<span id="cb42-129"><a href="#cb42-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-130"><a href="#cb42-130" aria-hidden="true" tabindex="-1"></a>The authors have demonstrated how they developed their idea by first showcasing a greedy KL-LUCB strategy <span class="co">[</span><span class="ot">@kl_lucb_kaufmann</span><span class="co">]</span> based method and then extending it to include a beam search approach. </span>
<span id="cb42-131"><a href="#cb42-131" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-132"><a href="#cb42-132" aria-hidden="true" tabindex="-1"></a>In the paper anchors are constructed using a bottom up strategy where they start off with an empty anchor $\mathcal{A} = {}$ that would cover the entire feature space initially. In each iteration, a set of possible predicates is generated ${a_i}, i = {1,2,\dots, k}$ and the current anchor is extended with these possible predicates to create a set of possible anchors. Picking the right predicate to extend the current anchor with will be decided by the multi-arm bandit solution. In the formulated multi-arm bandit problem, the possible feature predicates were the choices while the reward from pulling a choice was the precision obtained with the pulled feature predicate in the final anchor. Once a predicate has been selected, if the current anchor combined with the new feature predicate satisfies the following criteria</span>
<span id="cb42-133"><a href="#cb42-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-134"><a href="#cb42-134" aria-hidden="true" tabindex="-1"></a>$$ </span>
<span id="cb42-135"><a href="#cb42-135" aria-hidden="true" tabindex="-1"></a>\text{Pr}(\text{Prec}(\mathcal{A}) \ge \tau) \ge 1 - \delta</span>
<span id="cb42-136"><a href="#cb42-136" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-137"><a href="#cb42-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-138"><a href="#cb42-138" aria-hidden="true" tabindex="-1"></a>then the process terminates early to provide the derived anchor. Notice how they were not trying to maximize the coverage but were only trying to pick the candidate that gave the highest precision. Since they are starting with an empty anchor the coverage is high and with every new predicate attached the coverage reduces slowly. They assume that the anchors with a smaller number of predicates would generally have higher coverage.</span>
<span id="cb42-139"><a href="#cb42-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-140"><a href="#cb42-140" aria-hidden="true" tabindex="-1"></a>It is limiting to have only one anchor considered as the solution as they would not be exploring other possible solutions. Therefore a set of possible anchors is considered in a beam search approach. The KL LUCB approach is modified to select $B$ number of best candidates. From these candidates, the final output will give the one with the highest coverage.</span>
<span id="cb42-141"><a href="#cb42-141" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-142"><a href="#cb42-142" aria-hidden="true" tabindex="-1"></a><span class="fu">## Evaluation</span></span>
<span id="cb42-143"><a href="#cb42-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-144"><a href="#cb42-144" aria-hidden="true" tabindex="-1"></a>Evaluating explainability methods quantitatively is a difficult and seemingly impossible task without utilizing a user study. In this case, anchors is evaluated using both simulated and actual users. </span>
<span id="cb42-145"><a href="#cb42-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-146"><a href="#cb42-146" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- We evaluate anchor explanations for complex models on a</span></span>
<span id="cb42-147"><a href="#cb42-147" aria-hidden="true" tabindex="-1"></a><span class="co">number of tasks, primarily focusing on how they facilitate</span></span>
<span id="cb42-148"><a href="#cb42-148" aria-hidden="true" tabindex="-1"></a><span class="co">accurate predictions by users (simulated and human) on the</span></span>
<span id="cb42-149"><a href="#cb42-149" aria-hidden="true" tabindex="-1"></a><span class="co">behaviour of the models on unseen instances. For simulated users, we use the tabular datasets previously</span></span>
<span id="cb42-150"><a href="#cb42-150" aria-hidden="true" tabindex="-1"></a><span class="co">mentioned (adult, rcdv and lending). Each dataset is split</span></span>
<span id="cb42-151"><a href="#cb42-151" aria-hidden="true" tabindex="-1"></a><span class="co">such that models are trained with the training set, explanations</span></span>
<span id="cb42-152"><a href="#cb42-152" aria-hidden="true" tabindex="-1"></a><span class="co">are produced for instances in the validation set, and</span></span>
<span id="cb42-153"><a href="#cb42-153" aria-hidden="true" tabindex="-1"></a><span class="co">evaluated on instances in the test set. For each dataset, we</span></span>
<span id="cb42-154"><a href="#cb42-154" aria-hidden="true" tabindex="-1"></a><span class="co">train three different models: logistic regression (lr), 400 gradient</span></span>
<span id="cb42-155"><a href="#cb42-155" aria-hidden="true" tabindex="-1"></a><span class="co">boosted trees (gb) and a multilayer perceptron with</span></span>
<span id="cb42-156"><a href="#cb42-156" aria-hidden="true" tabindex="-1"></a><span class="co">two layers of 50 units each (nn).We generate both linear</span></span>
<span id="cb42-157"><a href="#cb42-157" aria-hidden="true" tabindex="-1"></a><span class="co">LIME (Ribeiro, Singh, and Guestrin 2016b) and anchor explanations</span></span>
<span id="cb42-158"><a href="#cb42-158" aria-hidden="true" tabindex="-1"></a><span class="co">for them. When simulating users, we compute coverage (what fraction</span></span>
<span id="cb42-159"><a href="#cb42-159" aria-hidden="true" tabindex="-1"></a><span class="co">of the instances they predict after seeing explanations)</span></span>
<span id="cb42-160"><a href="#cb42-160" aria-hidden="true" tabindex="-1"></a><span class="co">and precision (what fraction of the predictions were correct)</span></span>
<span id="cb42-161"><a href="#cb42-161" aria-hidden="true" tabindex="-1"></a><span class="co">on the complete test set. For each dataset, model, and explanation</span></span>
<span id="cb42-162"><a href="#cb42-162" aria-hidden="true" tabindex="-1"></a><span class="co">type, we compute these metrics for the explanation</span></span>
<span id="cb42-163"><a href="#cb42-163" aria-hidden="true" tabindex="-1"></a><span class="co">of each instance in the validation data. Simulating when an</span></span>
<span id="cb42-164"><a href="#cb42-164" aria-hidden="true" tabindex="-1"></a><span class="co">anchor applies is clear. It is not obvious, however, how real</span></span>
<span id="cb42-165"><a href="#cb42-165" aria-hidden="true" tabindex="-1"></a><span class="co">users would use LIME explanations. Ideally, they should</span></span>
<span id="cb42-166"><a href="#cb42-166" aria-hidden="true" tabindex="-1"></a><span class="co">only apply explanations to examples that are close, but it is</span></span>
<span id="cb42-167"><a href="#cb42-167" aria-hidden="true" tabindex="-1"></a><span class="co">not clear what the distance function and the threshold for</span></span>
<span id="cb42-168"><a href="#cb42-168" aria-hidden="true" tabindex="-1"></a><span class="co">“close” should be, or if users compute distances on demand.</span></span>
<span id="cb42-169"><a href="#cb42-169" aria-hidden="true" tabindex="-1"></a><span class="co">Therefore, in this section, we simulate different behaviours,</span></span>
<span id="cb42-170"><a href="#cb42-170" aria-hidden="true" tabindex="-1"></a><span class="co">and perform a study with real users in the following section. --&gt;</span></span>
<span id="cb42-171"><a href="#cb42-171" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-172"><a href="#cb42-172" aria-hidden="true" tabindex="-1"></a><span class="fu">### Simulated user study</span></span>
<span id="cb42-173"><a href="#cb42-173" aria-hidden="true" tabindex="-1"></a>The concept of simulating users is a novel and interesting concept. In this paper, the authors have used several popular tabular datasets in the machine learning field that are focused on classification tasks (e.g. The <span class="in">`adult`</span> dataset contains features of adults in America and the task is to predict if their annual salary would be above or below 50,000$). Each dataset would be split into three components: training, validation and testing. For each training dataset, a logistic regression model, a gradient boosted tree and a multilayer perceptron were trained to derive explanations. To compare the performance of anchors they have picked a similar method of generating model agnostic local explanations called LIME<span class="co">[</span><span class="ot">@ribeiro_why_2016</span><span class="co">]</span>. For each instance in validation datasets, explanations will be generated using both LIME and anchors. The evaluation metric was set to be coverage and precision, where coverage was calculated based on the fraction of the instances a simulated user would predict after seeing explanations while precision was calculated based on the fraction of the correct predictions taken on the complete test set. While it is easy to calculate the coverage and precision based on the explanations of anchors since they are rule based methods, calculating how a user would apply LIME explanations was difficult as LIME explanations contained only the effect of the features on a given local instance. Therefore they have simulated two user types where one group would apply the LIME explanations naively while the other group would apply the LIME explanation if it is above a certain threshold. </span>
<span id="cb42-174"><a href="#cb42-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-175"><a href="#cb42-175" aria-hidden="true" tabindex="-1"></a><span class="fu">### Real world user study</span></span>
<span id="cb42-176"><a href="#cb42-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-177"><a href="#cb42-177" aria-hidden="true" tabindex="-1"></a>The real world user study utilized 26 students following a machine learning course. The users were first told to predict the behaviour of the model without seeing any explanations and also after seeing one or two rounds of explanations from LIME or anchors. The procedure and evaluation criteria were roughly similar to the simulated user study. In the real world user study, the lending dataset used in the simulated dataset has not being used and instead several visual quastion answering dataset were used. Also in addition to the coverage and precision, the time to give predictions were also considered as an evaluation metric between lime and anchors.</span>
<span id="cb42-178"><a href="#cb42-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-179"><a href="#cb42-179" aria-hidden="true" tabindex="-1"></a><span class="fu">### Results</span></span>
<span id="cb42-180"><a href="#cb42-180" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-181"><a href="#cb42-181" aria-hidden="true" tabindex="-1"></a><span class="al">![Average precision and coverage with simulated users on 3 tabular datasets and 3 classifiers.](imgs/sim_user_study.png)</span>{#fig-sim-user-study}</span>
<span id="cb42-182"><a href="#cb42-182" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-183"><a href="#cb42-183" aria-hidden="true" tabindex="-1"></a><span class="al">![Average precision, coverage and time to provide predictions based on real world user study using 2 tabular datasets and 2 visual question answering set](imgs/real_user_study.png)</span>{#fig-real-user-study}</span>
<span id="cb42-184"><a href="#cb42-184" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-185"><a href="#cb42-185" aria-hidden="true" tabindex="-1"></a>The results of both the simulated and real world user study shows that anchors has outperformed lime in roughly all of the evaluation metrics. In both case studies, the users were able to predict the behavior of models on unseen instances precisely and in the case of the real world user study, with less effort as well (indicated by the less time it took to give predictions).</span>
<span id="cb42-186"><a href="#cb42-186" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-187"><a href="#cb42-187" aria-hidden="true" tabindex="-1"></a><span class="fu">## Existing Statistical Software</span></span>
<span id="cb42-188"><a href="#cb42-188" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-189"><a href="#cb42-189" aria-hidden="true" tabindex="-1"></a>Currently, the anchors package has been implemented in a Java package and an R package<span class="co">[</span><span class="ot">@anchors_R_pkg</span><span class="co">]</span>. However, the R package simply uses the Java package under the hood. While using the package for my research purposes I found the R package to be computationally inefficient and hard to debug as the underlying computation happens in a completely different environment which is difficult to inspect. Therefore I have decided to reimplement the anchors package in a pure R package that is computationally efficient while also being simple to debug and diagnose.</span>
<span id="cb42-190"><a href="#cb42-190" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-191"><a href="#cb42-191" aria-hidden="true" tabindex="-1"></a><span class="fu"># Anchors redesigned {#sec-anchors-from-scratch}</span></span>
<span id="cb42-192"><a href="#cb42-192" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-193"><a href="#cb42-193" aria-hidden="true" tabindex="-1"></a><span class="fu">## Implementing the foundation of anchors {#sec-def-anchors}</span></span>
<span id="cb42-194"><a href="#cb42-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-195"><a href="#cb42-195" aria-hidden="true" tabindex="-1"></a>Below I have defined anchors as a set or list of predicates, while a predicate is defined as the combination of a feature name, a logical operator and a constant value to compare with. The implementation uses <span class="in">`S7`</span> classes in R which is a severely new and experimental method of defining data structures in R.</span>
<span id="cb42-196"><a href="#cb42-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-197"><a href="#cb42-197" aria-hidden="true" tabindex="-1"></a><span class="fu">### `anchors and predicate`</span></span>
<span id="cb42-200"><a href="#cb42-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-201"><a href="#cb42-201" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: show</span></span>
<span id="cb42-202"><a href="#cb42-202" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Anchors and Predicate implementation using S7 classes"</span></span>
<span id="cb42-203"><a href="#cb42-203" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-204"><a href="#cb42-204" aria-hidden="true" tabindex="-1"></a>predicate <span class="ot">&lt;-</span> <span class="fu">new_class</span>(<span class="st">"predicate"</span>, </span>
<span id="cb42-205"><a href="#cb42-205" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties =</span> <span class="fu">list</span>(</span>
<span id="cb42-206"><a href="#cb42-206" aria-hidden="true" tabindex="-1"></a>    <span class="at">feature =</span> class_character,</span>
<span id="cb42-207"><a href="#cb42-207" aria-hidden="true" tabindex="-1"></a>    <span class="at">operator =</span> class_function,</span>
<span id="cb42-208"><a href="#cb42-208" aria-hidden="true" tabindex="-1"></a>    <span class="at">constant =</span> <span class="fu">new_union</span>(</span>
<span id="cb42-209"><a href="#cb42-209" aria-hidden="true" tabindex="-1"></a>      class_integer, class_double, class_character</span>
<span id="cb42-210"><a href="#cb42-210" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb42-211"><a href="#cb42-211" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb42-212"><a href="#cb42-212" aria-hidden="true" tabindex="-1"></a>  <span class="at">validator =</span> <span class="cf">function</span>(self) {</span>
<span id="cb42-213"><a href="#cb42-213" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-214"><a href="#cb42-214" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-215"><a href="#cb42-215" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-216"><a href="#cb42-216" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-217"><a href="#cb42-217" aria-hidden="true" tabindex="-1"></a>anchors <span class="ot">&lt;-</span> <span class="fu">new_class</span>(<span class="st">"anchors"</span>,</span>
<span id="cb42-218"><a href="#cb42-218" aria-hidden="true" tabindex="-1"></a>  <span class="at">properties =</span> <span class="fu">list</span>(</span>
<span id="cb42-219"><a href="#cb42-219" aria-hidden="true" tabindex="-1"></a>    <span class="at">predicates =</span> class_vector <span class="co"># a vector of predicate class</span></span>
<span id="cb42-220"><a href="#cb42-220" aria-hidden="true" tabindex="-1"></a>  ),</span>
<span id="cb42-221"><a href="#cb42-221" aria-hidden="true" tabindex="-1"></a>  <span class="at">validator =</span> <span class="cf">function</span>(self) {</span>
<span id="cb42-222"><a href="#cb42-222" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">all</span>(<span class="fu">sapply</span>(self<span class="sc">@</span>predicates, \(x) <span class="fu">S7_inherits</span>(x, predicate)))) {</span>
<span id="cb42-223"><a href="#cb42-223" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span>(<span class="st">"The list of predicates should all inherit from the predicate class "</span>)</span>
<span id="cb42-224"><a href="#cb42-224" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb42-225"><a href="#cb42-225" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-226"><a href="#cb42-226" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-227"><a href="#cb42-227" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-228"><a href="#cb42-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-229"><a href="#cb42-229" aria-hidden="true" tabindex="-1"></a>In addition, there are several other functions that I have defined that work on top of anchors to be used when generating anchors as utility functions.</span>
<span id="cb42-230"><a href="#cb42-230" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-231"><a href="#cb42-231" aria-hidden="true" tabindex="-1"></a><span class="fu">### `extend`</span></span>
<span id="cb42-232"><a href="#cb42-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-233"><a href="#cb42-233" aria-hidden="true" tabindex="-1"></a>As we are going to be iteratively generating predicates, an anchor should be extendable by a predicate. </span>
<span id="cb42-234"><a href="#cb42-234" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-237"><a href="#cb42-237" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-238"><a href="#cb42-238" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: show</span></span>
<span id="cb42-239"><a href="#cb42-239" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "extend method implementation"</span></span>
<span id="cb42-240"><a href="#cb42-240" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-241"><a href="#cb42-241" aria-hidden="true" tabindex="-1"></a>extend <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"extend"</span>, <span class="st">"x"</span>)</span>
<span id="cb42-242"><a href="#cb42-242" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param pred The predicate to extend x with</span></span>
<span id="cb42-243"><a href="#cb42-243" aria-hidden="true" tabindex="-1"></a><span class="co">#' @return Extended anchor</span></span>
<span id="cb42-244"><a href="#cb42-244" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(extend, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, pred) {</span>
<span id="cb42-245"><a href="#cb42-245" aria-hidden="true" tabindex="-1"></a>  x<span class="sc">@</span>predicates <span class="ot">&lt;-</span> <span class="fu">c</span>(x<span class="sc">@</span>predicates, pred)</span>
<span id="cb42-246"><a href="#cb42-246" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(x)</span>
<span id="cb42-247"><a href="#cb42-247" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-248"><a href="#cb42-248" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-249"><a href="#cb42-249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-250"><a href="#cb42-250" aria-hidden="true" tabindex="-1"></a><span class="fu">### `satisfies`</span></span>
<span id="cb42-251"><a href="#cb42-251" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-252"><a href="#cb42-252" aria-hidden="true" tabindex="-1"></a>Given a dataset the <span class="in">`satisfies`</span> function tells us how many of the data points are satisfied through the boundary defined by the anchor (i.e. how many data points are inside the boundary)</span>
<span id="cb42-253"><a href="#cb42-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-256"><a href="#cb42-256" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-257"><a href="#cb42-257" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: show</span></span>
<span id="cb42-258"><a href="#cb42-258" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "satisfies method implementation"</span></span>
<span id="cb42-259"><a href="#cb42-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-260"><a href="#cb42-260" aria-hidden="true" tabindex="-1"></a>satisfies <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"satisfies"</span>, <span class="st">"x"</span>)</span>
<span id="cb42-261"><a href="#cb42-261" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param data The dataframe to apply anchors on. Can be one instance or an entire dataset.</span></span>
<span id="cb42-262"><a href="#cb42-262" aria-hidden="true" tabindex="-1"></a><span class="co">#' @return A logical vector indicating whether the anchors satisfies `data`</span></span>
<span id="cb42-263"><a href="#cb42-263" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(satisfies, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, data) {</span>
<span id="cb42-264"><a href="#cb42-264" aria-hidden="true" tabindex="-1"></a>  predicate_cols <span class="ot">&lt;-</span> <span class="fu">sapply</span>(x<span class="sc">@</span>predicates, \(x) x<span class="sc">@</span>feature)</span>
<span id="cb42-265"><a href="#cb42-265" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">all</span>(predicate_cols <span class="sc">%in%</span> <span class="fu">colnames</span>(data))) {</span>
<span id="cb42-266"><a href="#cb42-266" aria-hidden="true" tabindex="-1"></a>    <span class="fu">stop</span>(glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb42-267"><a href="#cb42-267" aria-hidden="true" tabindex="-1"></a>      <span class="st">"Predicates contain the following columns </span><span class="sc">\n</span><span class="st"> {predicate_cols}</span><span class="sc">\n</span><span class="st">"</span>,</span>
<span id="cb42-268"><a href="#cb42-268" aria-hidden="true" tabindex="-1"></a>      <span class="st">"that might not be in the dataset with the following columns </span><span class="sc">\n</span><span class="st"> {colnames(data)}"</span></span>
<span id="cb42-269"><a href="#cb42-269" aria-hidden="true" tabindex="-1"></a>    ))</span>
<span id="cb42-270"><a href="#cb42-270" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-271"><a href="#cb42-271" aria-hidden="true" tabindex="-1"></a>  satis_list <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="cn">TRUE</span>, <span class="fu">nrow</span>(data))</span>
<span id="cb42-272"><a href="#cb42-272" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> (predicate <span class="cf">in</span> x<span class="sc">@</span>predicates) {</span>
<span id="cb42-273"><a href="#cb42-273" aria-hidden="true" tabindex="-1"></a>    result_list <span class="ot">&lt;-</span> predicate<span class="sc">@</span><span class="fu">operator</span>(data[[predicate<span class="sc">@</span>feature]], predicate<span class="sc">@</span>constant)</span>
<span id="cb42-274"><a href="#cb42-274" aria-hidden="true" tabindex="-1"></a>    satis_list <span class="ot">&lt;-</span> satis_list <span class="sc">&amp;</span> result_list</span>
<span id="cb42-275"><a href="#cb42-275" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-276"><a href="#cb42-276" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(satis_list)</span>
<span id="cb42-277"><a href="#cb42-277" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-278"><a href="#cb42-278" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-279"><a href="#cb42-279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-280"><a href="#cb42-280" aria-hidden="true" tabindex="-1"></a><span class="fu">### `precision`</span></span>
<span id="cb42-281"><a href="#cb42-281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-282"><a href="#cb42-282" aria-hidden="true" tabindex="-1"></a>The way precision is defined is by collecting samples from the perturbation distribution (i.e. the varied realities of the local instance) and then selecting the ones that are within the boundary to apply the model on top of those filtered points and calculating the proportion of class labels. </span>
<span id="cb42-283"><a href="#cb42-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-286"><a href="#cb42-286" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-287"><a href="#cb42-287" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: show</span></span>
<span id="cb42-288"><a href="#cb42-288" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "precision method implementation"</span></span>
<span id="cb42-289"><a href="#cb42-289" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-290"><a href="#cb42-290" aria-hidden="true" tabindex="-1"></a>precision <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"precision"</span>, <span class="st">"x"</span>)</span>
<span id="cb42-291"><a href="#cb42-291" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param model a predict function that will provide the predicted labels given a dataset</span></span>
<span id="cb42-292"><a href="#cb42-292" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.</span></span>
<span id="cb42-293"><a href="#cb42-293" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)</span></span>
<span id="cb42-294"><a href="#cb42-294" aria-hidden="true" tabindex="-1"></a><span class="co">#' @return named vector of proportions</span></span>
<span id="cb42-295"><a href="#cb42-295" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(precision, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, model, dist, <span class="at">n_samples =</span> <span class="dv">100</span>) {</span>
<span id="cb42-296"><a href="#cb42-296" aria-hidden="true" tabindex="-1"></a>  samples <span class="ot">&lt;-</span> <span class="fu">dist</span>(<span class="at">n =</span> n_samples)</span>
<span id="cb42-297"><a href="#cb42-297" aria-hidden="true" tabindex="-1"></a>  satisfying_rows <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">satisfies</span>(x, samples), <span class="at">arr.ind =</span> <span class="cn">TRUE</span>)</span>
<span id="cb42-298"><a href="#cb42-298" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">length</span>(satisfying_rows) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb42-299"><a href="#cb42-299" aria-hidden="true" tabindex="-1"></a>    <span class="fu">message</span>(<span class="st">"No satisfying rows found in samples"</span>)</span>
<span id="cb42-300"><a href="#cb42-300" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb42-301"><a href="#cb42-301" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-302"><a href="#cb42-302" aria-hidden="true" tabindex="-1"></a>  samples <span class="ot">&lt;-</span> samples <span class="sc">|&gt;</span></span>
<span id="cb42-303"><a href="#cb42-303" aria-hidden="true" tabindex="-1"></a>    dplyr<span class="sc">::</span><span class="fu">slice</span>(satisfying_rows)</span>
<span id="cb42-304"><a href="#cb42-304" aria-hidden="true" tabindex="-1"></a>  preds <span class="ot">&lt;-</span> <span class="fu">model</span>(samples)</span>
<span id="cb42-305"><a href="#cb42-305" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="at">prop =</span> <span class="fu">as.vector</span>(<span class="fu">table</span>(preds) <span class="sc">/</span> <span class="fu">sum</span>(<span class="fu">table</span>(preds))))</span>
<span id="cb42-306"><a href="#cb42-306" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-307"><a href="#cb42-307" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-308"><a href="#cb42-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-309"><a href="#cb42-309" aria-hidden="true" tabindex="-1"></a><span class="fu">### `coverage`</span></span>
<span id="cb42-310"><a href="#cb42-310" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-311"><a href="#cb42-311" aria-hidden="true" tabindex="-1"></a>Coverage is defined from an implementation perspective as the number of samples from the perturbation distribution that the anchor is satisfying.</span>
<span id="cb42-312"><a href="#cb42-312" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-315"><a href="#cb42-315" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-316"><a href="#cb42-316" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: show</span></span>
<span id="cb42-317"><a href="#cb42-317" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "coverage method implementation"</span></span>
<span id="cb42-318"><a href="#cb42-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-319"><a href="#cb42-319" aria-hidden="true" tabindex="-1"></a>coverage <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"coverage"</span>, <span class="st">"x"</span>)</span>
<span id="cb42-320"><a href="#cb42-320" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.</span></span>
<span id="cb42-321"><a href="#cb42-321" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)</span></span>
<span id="cb42-322"><a href="#cb42-322" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(coverage, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, dist, <span class="at">n_samples =</span> <span class="dv">100</span>) {</span>
<span id="cb42-323"><a href="#cb42-323" aria-hidden="true" tabindex="-1"></a>  samples <span class="ot">&lt;-</span> <span class="fu">dist</span>(<span class="at">n =</span> n_samples)</span>
<span id="cb42-324"><a href="#cb42-324" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">satisfies</span>(x, samples)))</span>
<span id="cb42-325"><a href="#cb42-325" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-326"><a href="#cb42-326" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-327"><a href="#cb42-327" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-328"><a href="#cb42-328" aria-hidden="true" tabindex="-1"></a><span class="fu">### Proposal for a new coverage method {#sec-prop-cover-area}</span></span>
<span id="cb42-329"><a href="#cb42-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-330"><a href="#cb42-330" aria-hidden="true" tabindex="-1"></a>However, it would be more sensible to have the coverage be defined by the area of the feature space that the anchor covers in comparison to the entire feature space. Therefore in this function I will be calculating the coverage based on the size of the bounding box compared to the entire dataset.</span>
<span id="cb42-331"><a href="#cb42-331" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-332"><a href="#cb42-332" aria-hidden="true" tabindex="-1"></a><span class="in">`coverage based on feature space`</span></span>
<span id="cb42-335"><a href="#cb42-335" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-336"><a href="#cb42-336" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: show</span></span>
<span id="cb42-337"><a href="#cb42-337" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Coverage using area of the bounding box"</span></span>
<span id="cb42-338"><a href="#cb42-338" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-339"><a href="#cb42-339" aria-hidden="true" tabindex="-1"></a>coverage_area <span class="ot">&lt;-</span> S7<span class="sc">::</span><span class="fu">new_generic</span>(<span class="st">"coverage_area"</span>, <span class="st">"x"</span>)</span>
<span id="cb42-340"><a href="#cb42-340" aria-hidden="true" tabindex="-1"></a><span class="co">#' @param dataset the dataset used to calculate the area upon</span></span>
<span id="cb42-341"><a href="#cb42-341" aria-hidden="true" tabindex="-1"></a>S7<span class="sc">::</span><span class="fu">method</span>(coverage_area, anchors) <span class="ot">&lt;-</span> <span class="cf">function</span>(x, dataset) {</span>
<span id="cb42-342"><a href="#cb42-342" aria-hidden="true" tabindex="-1"></a>  little_box <span class="ot">&lt;-</span> dataset[<span class="fu">satisfies</span>(x, dataset), ]</span>
<span id="cb42-343"><a href="#cb42-343" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">calculate_area</span>(little_box) <span class="sc">/</span> <span class="fu">calculate_area</span>(dataset))</span>
<span id="cb42-344"><a href="#cb42-344" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-345"><a href="#cb42-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-346"><a href="#cb42-346" aria-hidden="true" tabindex="-1"></a><span class="co">#' @description Calculates the area of the rectangular shape that encompasses the dataset by getting the range (max - min) of each column and multiplying the value across columns</span></span>
<span id="cb42-347"><a href="#cb42-347" aria-hidden="true" tabindex="-1"></a>calculate_area <span class="ot">&lt;-</span> <span class="cf">function</span>(data) {</span>
<span id="cb42-348"><a href="#cb42-348" aria-hidden="true" tabindex="-1"></a>  data <span class="sc">|&gt;</span> <span class="fu">map_dbl</span>(<span class="sc">~</span><span class="fu">max</span>(.x, <span class="at">na.rm =</span> T) <span class="sc">-</span> <span class="fu">min</span>(.x, <span class="at">na.rm =</span> T)) <span class="sc">|&gt;</span> <span class="fu">prod</span>()</span>
<span id="cb42-349"><a href="#cb42-349" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-350"><a href="#cb42-350" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-351"><a href="#cb42-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-352"><a href="#cb42-352" aria-hidden="true" tabindex="-1"></a><span class="fu">## Brute force approach on one dimensional data {#sec-brute-force-oned}</span></span>
<span id="cb42-353"><a href="#cb42-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-354"><a href="#cb42-354" aria-hidden="true" tabindex="-1"></a>Now that we have a rough idea of what anchors are, I will begin by reproducing the concepts given in the paper. Instead of simply reproducing the final algorithm mentioned in the paper I will be emulating the thought process of constructing the final solution by developing the idea of anchors with the simplest case to more advanced complex scenarios. Throughout this report I will be using random forest models as an example black box models for simplicity and ease of implementation.</span>
<span id="cb42-355"><a href="#cb42-355" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-356"><a href="#cb42-356" aria-hidden="true" tabindex="-1"></a>Let's explore the idea of anchors with a simple one dimensional example. First I generate data in the range of $<span class="co">[</span><span class="ot">0,1</span><span class="co">]</span>$ and assign a binary class based on the following criteria. </span>
<span id="cb42-357"><a href="#cb42-357" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-358"><a href="#cb42-358" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-359"><a href="#cb42-359" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb42-360"><a href="#cb42-360" aria-hidden="true" tabindex="-1"></a>Y =</span>
<span id="cb42-361"><a href="#cb42-361" aria-hidden="true" tabindex="-1"></a>    \begin{cases}</span>
<span id="cb42-362"><a href="#cb42-362" aria-hidden="true" tabindex="-1"></a>        1 &amp; \text{if } \sin(15 \cdot x) &gt; 0 <span class="sc">\\</span></span>
<span id="cb42-363"><a href="#cb42-363" aria-hidden="true" tabindex="-1"></a>        0 &amp; \text{if } \sin(15 \cdot x) &lt; 0</span>
<span id="cb42-364"><a href="#cb42-364" aria-hidden="true" tabindex="-1"></a>    \end{cases}</span>
<span id="cb42-365"><a href="#cb42-365" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb42-366"><a href="#cb42-366" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-367"><a href="#cb42-367" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-368"><a href="#cb42-368" aria-hidden="true" tabindex="-1"></a>This dataset will be considered as the population from which I would collect a sample dataset to consider as the observed data. The observed data will then be segmented into training and testing data to develop black box models. For demonstration purposes I would be using only the training dataset to generate and test anchors on.</span>
<span id="cb42-369"><a href="#cb42-369" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-370"><a href="#cb42-370" aria-hidden="true" tabindex="-1"></a><span class="fu">### Generating data</span></span>
<span id="cb42-371"><a href="#cb42-371" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-374"><a href="#cb42-374" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-375"><a href="#cb42-375" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-376"><a href="#cb42-376" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code to generate one dimensional data"</span></span>
<span id="cb42-377"><a href="#cb42-377" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-378"><a href="#cb42-378" aria-hidden="true" tabindex="-1"></a><span class="co"># get the population x</span></span>
<span id="cb42-379"><a href="#cb42-379" aria-hidden="true" tabindex="-1"></a>pop_x <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="at">by =</span> <span class="fl">0.01</span>)</span>
<span id="cb42-380"><a href="#cb42-380" aria-hidden="true" tabindex="-1"></a><span class="co"># assign a class</span></span>
<span id="cb42-381"><a href="#cb42-381" aria-hidden="true" tabindex="-1"></a>outcome <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="fu">sin</span>(<span class="dv">15</span> <span class="sc">*</span> pop_x) <span class="sc">&gt;</span> <span class="dv">0</span>, <span class="st">"Plus"</span>, <span class="st">"Minus"</span>)</span>
<span id="cb42-382"><a href="#cb42-382" aria-hidden="true" tabindex="-1"></a>pop_data <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">x =</span> pop_x, <span class="at">class =</span> <span class="fu">factor</span>(outcome))</span>
<span id="cb42-383"><a href="#cb42-383" aria-hidden="true" tabindex="-1"></a><span class="co"># visualize population</span></span>
<span id="cb42-384"><a href="#cb42-384" aria-hidden="true" tabindex="-1"></a>pop_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pop_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span><span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb42-385"><a href="#cb42-385" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-386"><a href="#cb42-386" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">subtitle =</span> <span class="st">"Population data for 1 dimension"</span>, <span class="at">y =</span> <span class="st">""</span>)</span>
<span id="cb42-387"><a href="#cb42-387" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-388"><a href="#cb42-388" aria-hidden="true" tabindex="-1"></a><span class="co"># sample half of it</span></span>
<span id="cb42-389"><a href="#cb42-389" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">100</span>)</span>
<span id="cb42-390"><a href="#cb42-390" aria-hidden="true" tabindex="-1"></a>sample_data <span class="ot">&lt;-</span> pop_data <span class="sc">|&gt;</span> <span class="fu">slice_sample</span>(<span class="at">prop =</span> <span class="fl">0.5</span>, <span class="at">by =</span> class)</span>
<span id="cb42-391"><a href="#cb42-391" aria-hidden="true" tabindex="-1"></a>obs_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(sample_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span><span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb42-392"><a href="#cb42-392" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-393"><a href="#cb42-393" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">subtitle =</span> <span class="st">"Observed sample data"</span>, <span class="at">y =</span> <span class="st">""</span>)</span>
<span id="cb42-394"><a href="#cb42-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-395"><a href="#cb42-395" aria-hidden="true" tabindex="-1"></a><span class="co"># create a training and testing set</span></span>
<span id="cb42-396"><a href="#cb42-396" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">200</span>)</span>
<span id="cb42-397"><a href="#cb42-397" aria-hidden="true" tabindex="-1"></a>train_df <span class="ot">&lt;-</span> sample_data <span class="sc">|&gt;</span> <span class="fu">slice_sample</span>(<span class="at">prop =</span> <span class="fl">0.7</span>, <span class="at">by =</span> class)</span>
<span id="cb42-398"><a href="#cb42-398" aria-hidden="true" tabindex="-1"></a>train_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(train_df, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span><span class="dv">0</span>)) <span class="sc">+</span></span>
<span id="cb42-399"><a href="#cb42-399" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-400"><a href="#cb42-400" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">subtitle =</span> <span class="st">"Training data"</span>, <span class="at">y =</span> <span class="st">""</span>)</span>
<span id="cb42-401"><a href="#cb42-401" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-402"><a href="#cb42-402" aria-hidden="true" tabindex="-1"></a>pop_plot <span class="sc">/</span> obs_plot <span class="sc">/</span> train_plot</span>
<span id="cb42-403"><a href="#cb42-403" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-404"><a href="#cb42-404" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-405"><a href="#cb42-405" aria-hidden="true" tabindex="-1"></a>Afterwards I will be fitting a simple random forest model with 10 trees.</span>
<span id="cb42-406"><a href="#cb42-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-409"><a href="#cb42-409" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-410"><a href="#cb42-410" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-411"><a href="#cb42-411" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code to fit random forest model"</span></span>
<span id="cb42-412"><a href="#cb42-412" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-413"><a href="#cb42-413" aria-hidden="true" tabindex="-1"></a><span class="co"># fit a randomforest model</span></span>
<span id="cb42-414"><a href="#cb42-414" aria-hidden="true" tabindex="-1"></a>rfmodel <span class="ot">&lt;-</span> <span class="fu">randomForest</span>(class <span class="sc">~</span> x, <span class="at">data =</span> train_df, <span class="at">ntree =</span> <span class="dv">10</span>)</span>
<span id="cb42-415"><a href="#cb42-415" aria-hidden="true" tabindex="-1"></a>rfmodel</span>
<span id="cb42-416"><a href="#cb42-416" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-417"><a href="#cb42-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-418"><a href="#cb42-418" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- Now how do we explain the decision process of this black box model using anchors. While it is possible to explain the decision process of a randomforest model with 10 trees fitted on a 1-dimensional data, we want to start explaining the process of anchors with a simpler case of one dimensional data. --&gt;</span></span>
<span id="cb42-419"><a href="#cb42-419" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-420"><a href="#cb42-420" aria-hidden="true" tabindex="-1"></a><span class="fu">### Demonstration on a single point {#sec-demo-single-inst}</span></span>
<span id="cb42-421"><a href="#cb42-421" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-422"><a href="#cb42-422" aria-hidden="true" tabindex="-1"></a>Let us first pick a data point in the dataset. Ideally a point in a border would be best to illustrate the idea.</span>
<span id="cb42-423"><a href="#cb42-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-426"><a href="#cb42-426" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-427"><a href="#cb42-427" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-428"><a href="#cb42-428" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-429"><a href="#cb42-429" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb42-430"><a href="#cb42-430" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(</span>
<span id="cb42-431"><a href="#cb42-431" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb42-432"><a href="#cb42-432" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-433"><a href="#cb42-433" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb42-434"><a href="#cb42-434" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-435"><a href="#cb42-435" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-436"><a href="#cb42-436" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-437"><a href="#cb42-437" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>))</span>
<span id="cb42-438"><a href="#cb42-438" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-439"><a href="#cb42-439" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-440"><a href="#cb42-440" aria-hidden="true" tabindex="-1"></a>For a one dimensional example, a boundary region would be defined by two values, a value left to the given value and a value right to the given value. The values for these bounding boxes will be generated based on the midpoints between observed data points. This would ensure that I will not be generating bounding boxes in areas that are not plausible for the original dataset. </span>
<span id="cb42-441"><a href="#cb42-441" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-444"><a href="#cb42-444" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-445"><a href="#cb42-445" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-446"><a href="#cb42-446" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code to generate cutpoints"</span></span>
<span id="cb42-447"><a href="#cb42-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-448"><a href="#cb42-448" aria-hidden="true" tabindex="-1"></a>x_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"x"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb42-449"><a href="#cb42-449" aria-hidden="true" tabindex="-1"></a>x_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(x_vals[<span class="sc">-</span><span class="fu">length</span>(x_vals)], x_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb42-450"><a href="#cb42-450" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb42-451"><a href="#cb42-451" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb42-452"><a href="#cb42-452" aria-hidden="true" tabindex="-1"></a>x_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb42-453"><a href="#cb42-453" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>x],</span>
<span id="cb42-454"><a href="#cb42-454" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>x]</span>
<span id="cb42-455"><a href="#cb42-455" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> <span class="fu">rename</span>(<span class="at">a =</span> Var1, <span class="at">b =</span> Var2)</span>
<span id="cb42-456"><a href="#cb42-456" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-457"><a href="#cb42-457" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-460"><a href="#cb42-460" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-461"><a href="#cb42-461" aria-hidden="true" tabindex="-1"></a><span class="co">#| echo: false</span></span>
<span id="cb42-462"><a href="#cb42-462" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: false</span></span>
<span id="cb42-463"><a href="#cb42-463" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(</span>
<span id="cb42-464"><a href="#cb42-464" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb42-465"><a href="#cb42-465" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-466"><a href="#cb42-466" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb42-467"><a href="#cb42-467" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-468"><a href="#cb42-468" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-469"><a href="#cb42-469" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-470"><a href="#cb42-470" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-471"><a href="#cb42-471" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">data =</span> x_grid, <span class="fu">aes</span>(<span class="at">xintercept =</span> a), <span class="at">color =</span> <span class="st">"purple"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">alpha =</span> <span class="fl">0.4</span>) <span class="sc">+</span></span>
<span id="cb42-472"><a href="#cb42-472" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">data =</span> x_grid, <span class="fu">aes</span>(<span class="at">xintercept =</span> b), <span class="at">color =</span> <span class="st">"gray"</span>, <span class="at">linetype =</span> <span class="st">"dashed"</span>, <span class="at">alpha =</span> <span class="fl">0.8</span>)</span>
<span id="cb42-473"><a href="#cb42-473" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-474"><a href="#cb42-474" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-475"><a href="#cb42-475" aria-hidden="true" tabindex="-1"></a>Let's visualize how a few bounding boxes should look like,</span>
<span id="cb42-476"><a href="#cb42-476" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-479"><a href="#cb42-479" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-480"><a href="#cb42-480" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-481"><a href="#cb42-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-482"><a href="#cb42-482" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(</span>
<span id="cb42-483"><a href="#cb42-483" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb42-484"><a href="#cb42-484" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-485"><a href="#cb42-485" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb42-486"><a href="#cb42-486" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-487"><a href="#cb42-487" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-488"><a href="#cb42-488" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-489"><a href="#cb42-489" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-490"><a href="#cb42-490" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-491"><a href="#cb42-491" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> x_grid <span class="sc">|&gt;</span></span>
<span id="cb42-492"><a href="#cb42-492" aria-hidden="true" tabindex="-1"></a>      <span class="fu">slice_sample</span>(<span class="at">n =</span> <span class="dv">3</span>) <span class="sc">|&gt;</span></span>
<span id="cb42-493"><a href="#cb42-493" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mutate</span>(<span class="at">id =</span> <span class="fu">row_number</span>()),</span>
<span id="cb42-494"><a href="#cb42-494" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>, <span class="at">color =</span> <span class="fu">factor</span>(id)),</span>
<span id="cb42-495"><a href="#cb42-495" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-496"><a href="#cb42-496" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-497"><a href="#cb42-497" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span></span>
<span id="cb42-498"><a href="#cb42-498" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span> </span>
<span id="cb42-499"><a href="#cb42-499" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Sample bounding boxes"</span>, <span class="at">color =</span> <span class="st">"Bounding box ID"</span>)</span>
<span id="cb42-500"><a href="#cb42-500" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-501"><a href="#cb42-501" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-502"><a href="#cb42-502" aria-hidden="true" tabindex="-1"></a>For a one dimensional example the simplest solution would be to apply a brute force approach and calculate the precision and coverage for all the possible bounding boxes. Notice that since I am starting off with boundaries that already contain the point and extending forward **I am changing the algorithm from the bottom up approach as mentioned in the paper to a top down approach in the upcoming sections**. In order to calculate the precision and coverage I would need to define the model function $f$ and the perturbation distribution $D$. For this specific case, the perturbation distribution would be giving out all the possible values for the one dimension which would be the same set of values used in the population data i.e. $<span class="co">[</span><span class="ot">0.01,0.02, \dots, 0.99, 1.00</span><span class="co">]</span>$.</span>
<span id="cb42-503"><a href="#cb42-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-506"><a href="#cb42-506" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-507"><a href="#cb42-507" aria-hidden="true" tabindex="-1"></a>model_func <span class="ot">&lt;-</span> <span class="cf">function</span>(data_samples) {</span>
<span id="cb42-508"><a href="#cb42-508" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">predict</span>(rfmodel, data_samples))</span>
<span id="cb42-509"><a href="#cb42-509" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-510"><a href="#cb42-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-511"><a href="#cb42-511" aria-hidden="true" tabindex="-1"></a>dist_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) <span class="fu">data.frame</span>(<span class="at">x =</span> <span class="fu">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>,<span class="at">by =</span> <span class="fl">0.01</span>))</span>
<span id="cb42-512"><a href="#cb42-512" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-513"><a href="#cb42-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-514"><a href="#cb42-514" aria-hidden="true" tabindex="-1"></a><span class="fu">### Brute force approach</span></span>
<span id="cb42-515"><a href="#cb42-515" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-518"><a href="#cb42-518" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-519"><a href="#cb42-519" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-520"><a href="#cb42-520" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Code for brute force approach"</span></span>
<span id="cb42-521"><a href="#cb42-521" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-522"><a href="#cb42-522" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> x_grid <span class="sc">|&gt;</span> <span class="fu">apply</span>(<span class="dv">1</span>, <span class="cf">function</span>(row) {</span>
<span id="cb42-523"><a href="#cb42-523" aria-hidden="true" tabindex="-1"></a>  bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(</span>
<span id="cb42-524"><a href="#cb42-524" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"a"</span>]),</span>
<span id="cb42-525"><a href="#cb42-525" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"b"</span>])</span>
<span id="cb42-526"><a href="#cb42-526" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb42-527"><a href="#cb42-527" aria-hidden="true" tabindex="-1"></a>  cover <span class="ot">&lt;-</span> <span class="fu">coverage</span>(bound, dist_func, <span class="at">n_samples =</span> <span class="dv">500</span>)</span>
<span id="cb42-528"><a href="#cb42-528" aria-hidden="true" tabindex="-1"></a>  cover_area <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x))</span>
<span id="cb42-529"><a href="#cb42-529" aria-hidden="true" tabindex="-1"></a>  prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">500</span>)</span>
<span id="cb42-530"><a href="#cb42-530" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">cover =</span> cover, <span class="at">cover_area =</span> cover_area, <span class="at">prec =</span> prec))</span>
<span id="cb42-531"><a href="#cb42-531" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb42-532"><a href="#cb42-532" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-533"><a href="#cb42-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-534"><a href="#cb42-534" aria-hidden="true" tabindex="-1"></a>There is an interesting pattern of the coverage and precision in the above plot. The coverage of high precision bounding boxes would be quite low which relates well to the real world scenario where smaller boundary boxes would be quite precise while larger boundary boxes would be having moderate precision.</span>
<span id="cb42-535"><a href="#cb42-535" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-536"><a href="#cb42-536" aria-hidden="true" tabindex="-1"></a>Once the brute force approach is applied I have the precision and coverage for all the bounding boxes. If I inspect the relationship between the precision and coverage it would be easier for us to identify which bounding box to select.</span>
<span id="cb42-537"><a href="#cb42-537" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-540"><a href="#cb42-540" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-541"><a href="#cb42-541" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-fold: true</span></span>
<span id="cb42-542"><a href="#cb42-542" aria-hidden="true" tabindex="-1"></a><span class="co">#| code-summary: "Visualizing the relationship between precision and coverage"</span></span>
<span id="cb42-543"><a href="#cb42-543" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-544"><a href="#cb42-544" aria-hidden="true" tabindex="-1"></a>res_df <span class="ot">&lt;-</span> res <span class="sc">|&gt;</span></span>
<span id="cb42-545"><a href="#cb42-545" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dfr</span>(<span class="sc">~</span> <span class="fu">tibble</span>(</span>
<span id="cb42-546"><a href="#cb42-546" aria-hidden="true" tabindex="-1"></a>      <span class="at">cover =</span> .x<span class="sc">$</span>cover,</span>
<span id="cb42-547"><a href="#cb42-547" aria-hidden="true" tabindex="-1"></a>      <span class="at">cover_area =</span> .x<span class="sc">$</span>cover_area,</span>
<span id="cb42-548"><a href="#cb42-548" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_1 =</span> .x<span class="sc">$</span>prec[<span class="dv">1</span>],</span>
<span id="cb42-549"><a href="#cb42-549" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_2 =</span> .x<span class="sc">$</span>prec[<span class="dv">2</span>])</span>
<span id="cb42-550"><a href="#cb42-550" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-551"><a href="#cb42-551" aria-hidden="true" tabindex="-1"></a>res_df <span class="sc">|&gt;</span></span>
<span id="cb42-552"><a href="#cb42-552" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> prec_1, <span class="at">y =</span> cover_area)) <span class="sc">+</span></span>
<span id="cb42-553"><a href="#cb42-553" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-554"><a href="#cb42-554" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb42-555"><a href="#cb42-555" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb42-556"><a href="#cb42-556" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for all possible bounding boxes in 1 dimension"</span>,</span>
<span id="cb42-557"><a href="#cb42-557" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb42-558"><a href="#cb42-558" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb42-559"><a href="#cb42-559" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-560"><a href="#cb42-560" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-561"><a href="#cb42-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-562"><a href="#cb42-562" aria-hidden="true" tabindex="-1"></a>Let us visualize the bounding box with the highest precision on both the population data and the training data.</span>
<span id="cb42-563"><a href="#cb42-563" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-566"><a href="#cb42-566" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-567"><a href="#cb42-567" aria-hidden="true" tabindex="-1"></a>max_prec_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb42-568"><a href="#cb42-568" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_max</span>(prec_1)</span>
<span id="cb42-569"><a href="#cb42-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-570"><a href="#cb42-570" aria-hidden="true" tabindex="-1"></a>max_prec_train_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb42-571"><a href="#cb42-571" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb42-572"><a href="#cb42-572" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-573"><a href="#cb42-573" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb42-574"><a href="#cb42-574" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-575"><a href="#cb42-575" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-576"><a href="#cb42-576" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb42-577"><a href="#cb42-577" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-578"><a href="#cb42-578" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-579"><a href="#cb42-579" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb42-580"><a href="#cb42-580" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-581"><a href="#cb42-581" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-582"><a href="#cb42-582" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-583"><a href="#cb42-583" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-584"><a href="#cb42-584" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-585"><a href="#cb42-585" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-586"><a href="#cb42-586" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb42-587"><a href="#cb42-587" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb42-588"><a href="#cb42-588" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>,</span>
<span id="cb42-589"><a href="#cb42-589" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span></span>
<span id="cb42-590"><a href="#cb42-590" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb42-591"><a href="#cb42-591" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>),</span>
<span id="cb42-592"><a href="#cb42-592" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are training data"</span></span>
<span id="cb42-593"><a href="#cb42-593" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-594"><a href="#cb42-594" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-595"><a href="#cb42-595" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-598"><a href="#cb42-598" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-599"><a href="#cb42-599" aria-hidden="true" tabindex="-1"></a>max_prec_pop_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb42-600"><a href="#cb42-600" aria-hidden="true" tabindex="-1"></a>  pop_data,</span>
<span id="cb42-601"><a href="#cb42-601" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-602"><a href="#cb42-602" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb42-603"><a href="#cb42-603" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-604"><a href="#cb42-604" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-605"><a href="#cb42-605" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb42-606"><a href="#cb42-606" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-607"><a href="#cb42-607" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-608"><a href="#cb42-608" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb42-609"><a href="#cb42-609" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-610"><a href="#cb42-610" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-611"><a href="#cb42-611" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-612"><a href="#cb42-612" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-613"><a href="#cb42-613" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-614"><a href="#cb42-614" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-615"><a href="#cb42-615" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb42-616"><a href="#cb42-616" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb42-617"><a href="#cb42-617" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>,</span>
<span id="cb42-618"><a href="#cb42-618" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span></span>
<span id="cb42-619"><a href="#cb42-619" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb42-620"><a href="#cb42-620" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>),</span>
<span id="cb42-621"><a href="#cb42-621" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span>)</span>
<span id="cb42-622"><a href="#cb42-622" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-623"><a href="#cb42-623" aria-hidden="true" tabindex="-1"></a>max_prec_pop_plot <span class="sc">/</span> max_prec_train_plot </span>
<span id="cb42-624"><a href="#cb42-624" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-625"><a href="#cb42-625" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-626"><a href="#cb42-626" aria-hidden="true" tabindex="-1"></a>The most optimal bounding box would be the one that has high coverage while having precision above a threshold (in this case 0.8). The most optimal bounding box would look like the following.</span>
<span id="cb42-627"><a href="#cb42-627" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-630"><a href="#cb42-630" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-631"><a href="#cb42-631" aria-hidden="true" tabindex="-1"></a>optimal_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb42-632"><a href="#cb42-632" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(cover), <span class="fu">desc</span>(prec_1)) <span class="sc">|&gt;</span></span>
<span id="cb42-633"><a href="#cb42-633" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(prec_1 <span class="sc">&gt;</span> <span class="fl">0.8</span>) <span class="sc">|&gt;</span> </span>
<span id="cb42-634"><a href="#cb42-634" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="dv">1</span>)</span>
<span id="cb42-635"><a href="#cb42-635" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-636"><a href="#cb42-636" aria-hidden="true" tabindex="-1"></a>optimal_bound_train_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb42-637"><a href="#cb42-637" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb42-638"><a href="#cb42-638" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-639"><a href="#cb42-639" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb42-640"><a href="#cb42-640" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-641"><a href="#cb42-641" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-642"><a href="#cb42-642" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb42-643"><a href="#cb42-643" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-644"><a href="#cb42-644" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-645"><a href="#cb42-645" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb42-646"><a href="#cb42-646" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-647"><a href="#cb42-647" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-648"><a href="#cb42-648" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-649"><a href="#cb42-649" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-650"><a href="#cb42-650" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-651"><a href="#cb42-651" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-652"><a href="#cb42-652" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb42-653"><a href="#cb42-653" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb42-654"><a href="#cb42-654" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>,</span>
<span id="cb42-655"><a href="#cb42-655" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span></span>
<span id="cb42-656"><a href="#cb42-656" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb42-657"><a href="#cb42-657" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>),</span>
<span id="cb42-658"><a href="#cb42-658" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are training data points"</span></span>
<span id="cb42-659"><a href="#cb42-659" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-660"><a href="#cb42-660" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-661"><a href="#cb42-661" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-664"><a href="#cb42-664" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-665"><a href="#cb42-665" aria-hidden="true" tabindex="-1"></a>optimal_bound_pop_plot <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(</span>
<span id="cb42-666"><a href="#cb42-666" aria-hidden="true" tabindex="-1"></a>  pop_data,</span>
<span id="cb42-667"><a href="#cb42-667" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-668"><a href="#cb42-668" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span> </span>
<span id="cb42-669"><a href="#cb42-669" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-670"><a href="#cb42-670" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-671"><a href="#cb42-671" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.007</span>) <span class="sc">+</span></span>
<span id="cb42-672"><a href="#cb42-672" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-673"><a href="#cb42-673" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-674"><a href="#cb42-674" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb42-675"><a href="#cb42-675" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-676"><a href="#cb42-676" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-677"><a href="#cb42-677" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-678"><a href="#cb42-678" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-679"><a href="#cb42-679" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-680"><a href="#cb42-680" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-681"><a href="#cb42-681" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb42-682"><a href="#cb42-682" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(</span>
<span id="cb42-683"><a href="#cb42-683" aria-hidden="true" tabindex="-1"></a>    <span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>,</span>
<span id="cb42-684"><a href="#cb42-684" aria-hidden="true" tabindex="-1"></a>    <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span></span>
<span id="cb42-685"><a href="#cb42-685" aria-hidden="true" tabindex="-1"></a>    ),</span>
<span id="cb42-686"><a href="#cb42-686" aria-hidden="true" tabindex="-1"></a>    <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>),</span>
<span id="cb42-687"><a href="#cb42-687" aria-hidden="true" tabindex="-1"></a>    <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span></span>
<span id="cb42-688"><a href="#cb42-688" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-689"><a href="#cb42-689" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-690"><a href="#cb42-690" aria-hidden="true" tabindex="-1"></a>optimal_bound_pop_plot <span class="sc">/</span> optimal_bound_train_plot</span>
<span id="cb42-691"><a href="#cb42-691" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-692"><a href="#cb42-692" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-693"><a href="#cb42-693" aria-hidden="true" tabindex="-1"></a><span class="fu">### Redemonstration for robustness</span></span>
<span id="cb42-694"><a href="#cb42-694" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-695"><a href="#cb42-695" aria-hidden="true" tabindex="-1"></a>Now let's attempt the above for a different point and see how the bounding box changes.</span>
<span id="cb42-696"><a href="#cb42-696" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-699"><a href="#cb42-699" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-700"><a href="#cb42-700" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> <span class="dv">6</span></span>
<span id="cb42-701"><a href="#cb42-701" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-702"><a href="#cb42-702" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(</span>
<span id="cb42-703"><a href="#cb42-703" aria-hidden="true" tabindex="-1"></a>  train_df[<span class="sc">-</span>local_instance, ],</span>
<span id="cb42-704"><a href="#cb42-704" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)</span>
<span id="cb42-705"><a href="#cb42-705" aria-hidden="true" tabindex="-1"></a>) <span class="sc">+</span></span>
<span id="cb42-706"><a href="#cb42-706" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-707"><a href="#cb42-707" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-708"><a href="#cb42-708" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-709"><a href="#cb42-709" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>))</span>
<span id="cb42-710"><a href="#cb42-710" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-711"><a href="#cb42-711" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-712"><a href="#cb42-712" aria-hidden="true" tabindex="-1"></a>I will need to generate a new set of possible bounding boxes that surround the new instance of interest. After generating these bounding boxes I can calculate the precision and accuracy for each of these bounding boxes and obtain the bounding box with the highest precision and the most optimal bounding box.</span>
<span id="cb42-713"><a href="#cb42-713" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-716"><a href="#cb42-716" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-717"><a href="#cb42-717" aria-hidden="true" tabindex="-1"></a>x_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"x"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb42-718"><a href="#cb42-718" aria-hidden="true" tabindex="-1"></a>x_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(x_vals[<span class="sc">-</span><span class="fu">length</span>(x_vals)], x_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb42-719"><a href="#cb42-719" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb42-720"><a href="#cb42-720" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb42-721"><a href="#cb42-721" aria-hidden="true" tabindex="-1"></a>x_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb42-722"><a href="#cb42-722" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>x],</span>
<span id="cb42-723"><a href="#cb42-723" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>x]</span>
<span id="cb42-724"><a href="#cb42-724" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> <span class="fu">rename</span>(<span class="at">a =</span> Var1, <span class="at">b =</span> Var2)</span>
<span id="cb42-725"><a href="#cb42-725" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-726"><a href="#cb42-726" aria-hidden="true" tabindex="-1"></a>res <span class="ot">&lt;-</span> x_grid <span class="sc">|&gt;</span> <span class="fu">apply</span>(<span class="dv">1</span>, <span class="cf">function</span>(row) {</span>
<span id="cb42-727"><a href="#cb42-727" aria-hidden="true" tabindex="-1"></a>  bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(</span>
<span id="cb42-728"><a href="#cb42-728" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"a"</span>]),</span>
<span id="cb42-729"><a href="#cb42-729" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> row[<span class="st">"b"</span>])</span>
<span id="cb42-730"><a href="#cb42-730" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb42-731"><a href="#cb42-731" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cover &lt;- coverage(bound, dist_func, n_samples = 500)</span></span>
<span id="cb42-732"><a href="#cb42-732" aria-hidden="true" tabindex="-1"></a>  cover <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, <span class="at">dataset =</span> train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x))</span>
<span id="cb42-733"><a href="#cb42-733" aria-hidden="true" tabindex="-1"></a>  prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">500</span>)</span>
<span id="cb42-734"><a href="#cb42-734" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">cover =</span> cover, <span class="at">prec =</span> prec))</span>
<span id="cb42-735"><a href="#cb42-735" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb42-736"><a href="#cb42-736" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-737"><a href="#cb42-737" aria-hidden="true" tabindex="-1"></a>res_df <span class="ot">&lt;-</span> res <span class="sc">|&gt;</span></span>
<span id="cb42-738"><a href="#cb42-738" aria-hidden="true" tabindex="-1"></a>  <span class="fu">map_dfr</span>(<span class="sc">~</span> <span class="fu">tibble</span>(</span>
<span id="cb42-739"><a href="#cb42-739" aria-hidden="true" tabindex="-1"></a>      <span class="at">cover =</span> .x<span class="sc">$</span>cover,</span>
<span id="cb42-740"><a href="#cb42-740" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_1 =</span> .x<span class="sc">$</span>prec[<span class="dv">1</span>],</span>
<span id="cb42-741"><a href="#cb42-741" aria-hidden="true" tabindex="-1"></a>      <span class="at">prec_2 =</span> .x<span class="sc">$</span>prec[<span class="dv">2</span>])</span>
<span id="cb42-742"><a href="#cb42-742" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-743"><a href="#cb42-743" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-744"><a href="#cb42-744" aria-hidden="true" tabindex="-1"></a>res_df <span class="sc">|&gt;</span></span>
<span id="cb42-745"><a href="#cb42-745" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> prec_1, <span class="at">y =</span> cover)) <span class="sc">+</span></span>
<span id="cb42-746"><a href="#cb42-746" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-747"><a href="#cb42-747" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb42-748"><a href="#cb42-748" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb42-749"><a href="#cb42-749" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for all possible bounding boxes in 1 dimension"</span>,</span>
<span id="cb42-750"><a href="#cb42-750" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb42-751"><a href="#cb42-751" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb42-752"><a href="#cb42-752" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-753"><a href="#cb42-753" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-754"><a href="#cb42-754" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-755"><a href="#cb42-755" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-758"><a href="#cb42-758" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-759"><a href="#cb42-759" aria-hidden="true" tabindex="-1"></a>max_prec_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb42-760"><a href="#cb42-760" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_max</span>(prec_1) <span class="sc">|&gt;</span></span>
<span id="cb42-761"><a href="#cb42-761" aria-hidden="true" tabindex="-1"></a>  <span class="co"># since there are more than one box with highest precision we will be selecting the bounding box we will be selecting a bounding box at random</span></span>
<span id="cb42-762"><a href="#cb42-762" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice_sample</span>(<span class="at">n =</span> <span class="dv">1</span>)</span>
<span id="cb42-763"><a href="#cb42-763" aria-hidden="true" tabindex="-1"></a>max_prec_train_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(train_df[<span class="sc">-</span>local_instance, ], <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-764"><a href="#cb42-764" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-765"><a href="#cb42-765" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-766"><a href="#cb42-766" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-767"><a href="#cb42-767" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb42-768"><a href="#cb42-768" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-769"><a href="#cb42-769" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-770"><a href="#cb42-770" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-771"><a href="#cb42-771" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-772"><a href="#cb42-772" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-773"><a href="#cb42-773" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-774"><a href="#cb42-774" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span> <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are training data"</span>)</span>
<span id="cb42-775"><a href="#cb42-775" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-776"><a href="#cb42-776" aria-hidden="true" tabindex="-1"></a>max_prec_pop_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pop_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-777"><a href="#cb42-777" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-778"><a href="#cb42-778" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-779"><a href="#cb42-779" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-780"><a href="#cb42-780" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> max_prec_bound,</span>
<span id="cb42-781"><a href="#cb42-781" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-782"><a href="#cb42-782" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-783"><a href="#cb42-783" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-784"><a href="#cb42-784" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-785"><a href="#cb42-785" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-786"><a href="#cb42-786" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-787"><a href="#cb42-787" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb42-788"><a href="#cb42-788" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(max_prec_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(max_prec_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {max_prec_bound$a} AND x &lt; {max_prec_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span>)</span>
<span id="cb42-789"><a href="#cb42-789" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-790"><a href="#cb42-790" aria-hidden="true" tabindex="-1"></a>optimal_bound <span class="ot">&lt;-</span> <span class="fu">bind_cols</span>(x_grid, res_df) <span class="sc">|&gt;</span></span>
<span id="cb42-791"><a href="#cb42-791" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(cover), <span class="fu">desc</span>(prec_1)) <span class="sc">|&gt;</span></span>
<span id="cb42-792"><a href="#cb42-792" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(prec_1 <span class="sc">&gt;</span> <span class="fl">0.8</span>) <span class="sc">|&gt;</span> </span>
<span id="cb42-793"><a href="#cb42-793" aria-hidden="true" tabindex="-1"></a>  <span class="fu">slice</span>(<span class="dv">1</span>)</span>
<span id="cb42-794"><a href="#cb42-794" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-795"><a href="#cb42-795" aria-hidden="true" tabindex="-1"></a>optimal_bound_train_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(train_df[<span class="sc">-</span>local_instance, ], <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-796"><a href="#cb42-796" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-797"><a href="#cb42-797" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-798"><a href="#cb42-798" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-799"><a href="#cb42-799" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb42-800"><a href="#cb42-800" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-801"><a href="#cb42-801" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-802"><a href="#cb42-802" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-803"><a href="#cb42-803" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-804"><a href="#cb42-804" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-805"><a href="#cb42-805" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-806"><a href="#cb42-806" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb42-807"><a href="#cb42-807" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are training data points"</span>)</span>
<span id="cb42-808"><a href="#cb42-808" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-809"><a href="#cb42-809" aria-hidden="true" tabindex="-1"></a>optimal_bound_pop_plot_alt <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(pop_data, <span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">color =</span> class, <span class="at">y =</span> <span class="dv">0</span>)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">size =</span> <span class="fl">2.5</span>) <span class="sc">+</span></span>
<span id="cb42-810"><a href="#cb42-810" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance,], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.005</span>) <span class="sc">+</span></span>
<span id="cb42-811"><a href="#cb42-811" aria-hidden="true" tabindex="-1"></a>  <span class="fu">lims</span>(<span class="at">y =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.05</span>, <span class="fl">0.05</span>)) <span class="sc">+</span></span>
<span id="cb42-812"><a href="#cb42-812" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(</span>
<span id="cb42-813"><a href="#cb42-813" aria-hidden="true" tabindex="-1"></a>    <span class="at">data =</span> optimal_bound,</span>
<span id="cb42-814"><a href="#cb42-814" aria-hidden="true" tabindex="-1"></a>    <span class="fu">aes</span>(<span class="at">xmin =</span> a, <span class="at">xmax =</span> b, <span class="at">ymin =</span> <span class="sc">-</span><span class="fl">0.05</span>,<span class="at">ymax =</span> <span class="fl">0.05</span>),</span>
<span id="cb42-815"><a href="#cb42-815" aria-hidden="true" tabindex="-1"></a>    <span class="at">linetype =</span> <span class="st">"dashed"</span>,</span>
<span id="cb42-816"><a href="#cb42-816" aria-hidden="true" tabindex="-1"></a>    <span class="at">color =</span> <span class="st">"purple"</span>,</span>
<span id="cb42-817"><a href="#cb42-817" aria-hidden="true" tabindex="-1"></a>    <span class="at">fill =</span> <span class="st">"transparent"</span>,</span>
<span id="cb42-818"><a href="#cb42-818" aria-hidden="true" tabindex="-1"></a>    <span class="at">inherit.aes =</span> <span class="cn">FALSE</span>,</span>
<span id="cb42-819"><a href="#cb42-819" aria-hidden="true" tabindex="-1"></a>    <span class="at">show.legend =</span> <span class="cn">FALSE</span></span>
<span id="cb42-820"><a href="#cb42-820" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">+</span></span>
<span id="cb42-821"><a href="#cb42-821" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Precision: {round(optimal_bound$prec_1,2)}"</span>, <span class="st">" Coverage = {round(optimal_bound$cover,2)}"</span>), <span class="at">subtitle =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"IF x &gt; {optimal_bound$a} AND x &lt; {optimal_bound$b}"</span>), <span class="at">caption =</span> <span class="st">"Plotted points are population points"</span>)</span>
<span id="cb42-822"><a href="#cb42-822" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-823"><a href="#cb42-823" aria-hidden="true" tabindex="-1"></a>(max_prec_train_plot <span class="sc">/</span> optimal_bound_train_plot) <span class="sc">|</span> (max_prec_train_plot_alt <span class="sc">/</span> optimal_bound_train_plot_alt)</span>
<span id="cb42-824"><a href="#cb42-824" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-825"><a href="#cb42-825" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-826"><a href="#cb42-826" aria-hidden="true" tabindex="-1"></a>In the above plot, the left hand side is the previous point while the right hand side is the alternative point. Optimizing for coverage has been proven to be slightly useful in giving a broader scope of the model boundary. Based on both these points and their decision rules, a user should be able to identify what the model boundary would look like through anchors. In this example, the user would know that most of the Minus points are to the left of the given point (left plot) while most of the Plus points are to the right of the given point (right plot).</span>
<span id="cb42-827"><a href="#cb42-827" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-828"><a href="#cb42-828" aria-hidden="true" tabindex="-1"></a><span class="fu">## Remarks on brute force approach</span></span>
<span id="cb42-829"><a href="#cb42-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-830"><a href="#cb42-830" aria-hidden="true" tabindex="-1"></a>The brute force approach is the simplest solution to get the exact solution for all of the possible bounding boxes. While it is practically rare to meet models with one variable which can not be explained through interpretable models this approach can be extended to two or higher dimensions to explore all the possible bounding boxes in a greedy manner.</span>
<span id="cb42-831"><a href="#cb42-831" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-832"><a href="#cb42-832" aria-hidden="true" tabindex="-1"></a><span class="fu">## Sequential Greedy Approach in two dimensions {#sec-seq-greedy}</span></span>
<span id="cb42-833"><a href="#cb42-833" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-834"><a href="#cb42-834" aria-hidden="true" tabindex="-1"></a>I am going to use the previous brute force approach sequentially across dimensions using the following two dimensional dataset.</span>
<span id="cb42-835"><a href="#cb42-835" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-838"><a href="#cb42-838" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-839"><a href="#cb42-839" aria-hidden="true" tabindex="-1"></a>w <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"wiggly.csv"</span>,</span>
<span id="cb42-840"><a href="#cb42-840" aria-hidden="true" tabindex="-1"></a>              <span class="at">col_select =</span> <span class="sc">-</span><span class="dv">1</span>,</span>
<span id="cb42-841"><a href="#cb42-841" aria-hidden="true" tabindex="-1"></a>              <span class="at">col_types =</span> <span class="fu">cols</span>(</span>
<span id="cb42-842"><a href="#cb42-842" aria-hidden="true" tabindex="-1"></a>                <span class="at">x =</span> <span class="fu">col_double</span>(),</span>
<span id="cb42-843"><a href="#cb42-843" aria-hidden="true" tabindex="-1"></a>                <span class="at">y =</span> <span class="fu">col_double</span>(),</span>
<span id="cb42-844"><a href="#cb42-844" aria-hidden="true" tabindex="-1"></a>                <span class="at">class =</span> <span class="fu">col_double</span>())) <span class="sc">|&gt;</span> </span>
<span id="cb42-845"><a href="#cb42-845" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">class =</span> <span class="fu">factor</span>(<span class="fu">ifelse</span>(class <span class="sc">==</span> <span class="dv">3</span>, <span class="st">"Positive"</span>, <span class="st">"Negative"</span>)))</span>
<span id="cb42-846"><a href="#cb42-846" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-847"><a href="#cb42-847" aria-hidden="true" tabindex="-1"></a>observed_2dim_plot <span class="ot">&lt;-</span> w <span class="sc">|&gt;</span> </span>
<span id="cb42-848"><a href="#cb42-848" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb42-849"><a href="#cb42-849" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-850"><a href="#cb42-850" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Observed data for 2 dimensions"</span>) <span class="sc">+</span></span>
<span id="cb42-851"><a href="#cb42-851" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_equal</span>()</span>
<span id="cb42-852"><a href="#cb42-852" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-853"><a href="#cb42-853" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-854"><a href="#cb42-854" aria-hidden="true" tabindex="-1"></a>Similar to the previous case I would be sampling a set fraction of data points to build the training dataset and fit a random forest model on top of it.</span>
<span id="cb42-855"><a href="#cb42-855" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-858"><a href="#cb42-858" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-859"><a href="#cb42-859" aria-hidden="true" tabindex="-1"></a><span class="co"># sample train data</span></span>
<span id="cb42-860"><a href="#cb42-860" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">69420</span>)</span>
<span id="cb42-861"><a href="#cb42-861" aria-hidden="true" tabindex="-1"></a>train_indices <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(w), <span class="fu">round</span>(<span class="fu">nrow</span>(w) <span class="sc">*</span> <span class="fl">0.8</span>))</span>
<span id="cb42-862"><a href="#cb42-862" aria-hidden="true" tabindex="-1"></a>train_2dim_plot <span class="ot">&lt;-</span> w[train_indices, ] <span class="sc">|&gt;</span> </span>
<span id="cb42-863"><a href="#cb42-863" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb42-864"><a href="#cb42-864" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-865"><a href="#cb42-865" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"Training data"</span>) <span class="sc">+</span> </span>
<span id="cb42-866"><a href="#cb42-866" aria-hidden="true" tabindex="-1"></a>  <span class="fu">coord_equal</span>()</span>
<span id="cb42-867"><a href="#cb42-867" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-868"><a href="#cb42-868" aria-hidden="true" tabindex="-1"></a>train_2dim_plot</span>
<span id="cb42-869"><a href="#cb42-869" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-870"><a href="#cb42-870" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-873"><a href="#cb42-873" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-874"><a href="#cb42-874" aria-hidden="true" tabindex="-1"></a>train_df <span class="ot">&lt;-</span> w[train_indices, ] <span class="sc">|&gt;</span> <span class="fu">mutate</span>(<span class="at">id =</span> <span class="fu">row_number</span>())</span>
<span id="cb42-875"><a href="#cb42-875" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(randomForest)</span>
<span id="cb42-876"><a href="#cb42-876" aria-hidden="true" tabindex="-1"></a>rfmodel <span class="ot">&lt;-</span> <span class="fu">randomForest</span>(class <span class="sc">~</span> x <span class="sc">+</span> y, <span class="at">data =</span> train_df, <span class="at">ntree =</span> <span class="dv">5</span>)</span>
<span id="cb42-877"><a href="#cb42-877" aria-hidden="true" tabindex="-1"></a>rfmodel</span>
<span id="cb42-878"><a href="#cb42-878" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-879"><a href="#cb42-879" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-880"><a href="#cb42-880" aria-hidden="true" tabindex="-1"></a>When selecting instances I will be selecting instances that the model is having difficulty predicting. These points are most likely situated in the boundary area and therefore would be ideal candidates for exploring how anchors work.</span>
<span id="cb42-881"><a href="#cb42-881" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-884"><a href="#cb42-884" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-885"><a href="#cb42-885" aria-hidden="true" tabindex="-1"></a><span class="co"># select instance</span></span>
<span id="cb42-886"><a href="#cb42-886" aria-hidden="true" tabindex="-1"></a>prob_matrix <span class="ot">&lt;-</span> <span class="fu">predict</span>(rfmodel, <span class="at">newdata =</span> train_df, <span class="at">type =</span> <span class="st">"prob"</span>) <span class="sc">|&gt;</span> </span>
<span id="cb42-887"><a href="#cb42-887" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb42-888"><a href="#cb42-888" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">id =</span> <span class="fu">row_number</span>())</span>
<span id="cb42-889"><a href="#cb42-889" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> prob_matrix[prob_matrix<span class="sc">$</span>Negative <span class="sc">==</span> <span class="fl">0.4</span>, <span class="st">"id"</span>]</span>
<span id="cb42-890"><a href="#cb42-890" aria-hidden="true" tabindex="-1"></a>local_instance <span class="ot">&lt;-</span> local_instance[<span class="dv">1</span>]</span>
<span id="cb42-891"><a href="#cb42-891" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-892"><a href="#cb42-892" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-895"><a href="#cb42-895" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-896"><a href="#cb42-896" aria-hidden="true" tabindex="-1"></a>train_df[<span class="sc">-</span>local_instance, ] <span class="sc">|&gt;</span></span>
<span id="cb42-897"><a href="#cb42-897" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb42-898"><a href="#cb42-898" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-899"><a href="#cb42-899" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">size =</span> <span class="dv">5</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb42-900"><a href="#cb42-900" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.05</span>)</span>
<span id="cb42-901"><a href="#cb42-901" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-902"><a href="#cb42-902" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-903"><a href="#cb42-903" aria-hidden="true" tabindex="-1"></a>Similar to the brute force approach I would want to generate bounding boxes in the 2 dimensional space. A bounding box would consist of lower bound and an upper bound in both x and y dimensions.</span>
<span id="cb42-904"><a href="#cb42-904" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-907"><a href="#cb42-907" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-908"><a href="#cb42-908" aria-hidden="true" tabindex="-1"></a><span class="co"># generate cutpoints</span></span>
<span id="cb42-909"><a href="#cb42-909" aria-hidden="true" tabindex="-1"></a>x_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"x"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb42-910"><a href="#cb42-910" aria-hidden="true" tabindex="-1"></a>x_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(x_vals[<span class="sc">-</span><span class="fu">length</span>(x_vals)], x_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb42-911"><a href="#cb42-911" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb42-912"><a href="#cb42-912" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb42-913"><a href="#cb42-913" aria-hidden="true" tabindex="-1"></a>x_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb42-914"><a href="#cb42-914" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>x],</span>
<span id="cb42-915"><a href="#cb42-915" aria-hidden="true" tabindex="-1"></a>  x_cutpoints[x_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>x]</span>
<span id="cb42-916"><a href="#cb42-916" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb42-917"><a href="#cb42-917" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">L =</span> Var1, <span class="at">U =</span> Var2)<span class="sc">|&gt;</span> </span>
<span id="cb42-918"><a href="#cb42-918" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">|&gt;</span></span>
<span id="cb42-919"><a href="#cb42-919" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(L), U)</span>
<span id="cb42-920"><a href="#cb42-920" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-921"><a href="#cb42-921" aria-hidden="true" tabindex="-1"></a>y_vals <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance,][[<span class="st">"y"</span>]] <span class="sc">|&gt;</span> <span class="fu">sort</span>()</span>
<span id="cb42-922"><a href="#cb42-922" aria-hidden="true" tabindex="-1"></a>y_cutpoints <span class="ot">&lt;-</span> purrr<span class="sc">::</span><span class="fu">map2_dbl</span>(y_vals[<span class="sc">-</span><span class="fu">length</span>(y_vals)], y_vals[<span class="sc">-</span><span class="dv">1</span>], <span class="cf">function</span>(x, x_1) {</span>
<span id="cb42-923"><a href="#cb42-923" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">mean</span>(<span class="fu">c</span>(x, x_1)))</span>
<span id="cb42-924"><a href="#cb42-924" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb42-925"><a href="#cb42-925" aria-hidden="true" tabindex="-1"></a>y_grid <span class="ot">&lt;-</span> <span class="fu">expand.grid</span>(</span>
<span id="cb42-926"><a href="#cb42-926" aria-hidden="true" tabindex="-1"></a>  y_cutpoints[y_cutpoints <span class="sc">&lt;</span> train_df[local_instance,]<span class="sc">$</span>y],</span>
<span id="cb42-927"><a href="#cb42-927" aria-hidden="true" tabindex="-1"></a>  y_cutpoints[y_cutpoints <span class="sc">&gt;</span> train_df[local_instance,]<span class="sc">$</span>y]</span>
<span id="cb42-928"><a href="#cb42-928" aria-hidden="true" tabindex="-1"></a>) <span class="sc">|&gt;</span> </span>
<span id="cb42-929"><a href="#cb42-929" aria-hidden="true" tabindex="-1"></a>  <span class="fu">rename</span>(<span class="at">L =</span> Var1, <span class="at">U =</span> Var2) <span class="sc">|&gt;</span> </span>
<span id="cb42-930"><a href="#cb42-930" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>() <span class="sc">|&gt;</span></span>
<span id="cb42-931"><a href="#cb42-931" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(<span class="fu">desc</span>(L), U)</span>
<span id="cb42-932"><a href="#cb42-932" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-933"><a href="#cb42-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-934"><a href="#cb42-934" aria-hidden="true" tabindex="-1"></a> A model function and perturbation distribution would need to be defined to evaluate the coverage and the precision of this task. In this case, the perturbation distribution would be giving out the first $n$ realization from $X_1, X_2, \dots, X_{10000}$ where $X_i \sim \mathcal{N}_2(\underline{\mathbf{0}}, \mathbf{I})$</span>
<span id="cb42-935"><a href="#cb42-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-938"><a href="#cb42-938" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-939"><a href="#cb42-939" aria-hidden="true" tabindex="-1"></a>pertub_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) {</span>
<span id="cb42-940"><a href="#cb42-940" aria-hidden="true" tabindex="-1"></a>  mulgar<span class="sc">::</span><span class="fu">rmvn</span>(<span class="at">n =</span> n, </span>
<span id="cb42-941"><a href="#cb42-941" aria-hidden="true" tabindex="-1"></a>               <span class="at">p =</span> <span class="dv">2</span>,</span>
<span id="cb42-942"><a href="#cb42-942" aria-hidden="true" tabindex="-1"></a>               <span class="at">mn =</span> train_df[local_instance, <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)] <span class="sc">|&gt;</span> </span>
<span id="cb42-943"><a href="#cb42-943" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">unlist</span>(),</span>
<span id="cb42-944"><a href="#cb42-944" aria-hidden="true" tabindex="-1"></a>               <span class="at">vc =</span> <span class="fu">cov</span>(train_df[,<span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)])</span>
<span id="cb42-945"><a href="#cb42-945" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb42-946"><a href="#cb42-946" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb42-947"><a href="#cb42-947" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rename</span>(<span class="at">x =</span> x1, <span class="at">y =</span> x2)</span>
<span id="cb42-948"><a href="#cb42-948" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-949"><a href="#cb42-949" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-950"><a href="#cb42-950" aria-hidden="true" tabindex="-1"></a>model_func <span class="ot">&lt;-</span> <span class="cf">function</span>(data_samples) {</span>
<span id="cb42-951"><a href="#cb42-951" aria-hidden="true" tabindex="-1"></a>  <span class="fu">suppressPackageStartupMessages</span>(<span class="fu">library</span>(randomForest)) <span class="co"># for future package</span></span>
<span id="cb42-952"><a href="#cb42-952" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">predict</span>(rfmodel, data_samples))</span>
<span id="cb42-953"><a href="#cb42-953" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-954"><a href="#cb42-954" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-955"><a href="#cb42-955" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb42-956"><a href="#cb42-956" aria-hidden="true" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">pertub_func</span>(<span class="at">n =</span> <span class="dv">10000</span>)</span>
<span id="cb42-957"><a href="#cb42-957" aria-hidden="true" tabindex="-1"></a>dist_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) samples[<span class="dv">1</span><span class="sc">:</span>n, ]</span>
<span id="cb42-958"><a href="#cb42-958" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-959"><a href="#cb42-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-960"><a href="#cb42-960" aria-hidden="true" tabindex="-1"></a>The sequentially greedy approach will first try to optimize the bounding box on one dimension in this case the $x$ dimension. Once an ideal bounding region for one dimension has been found it will then fix the boundary in that dimension and optimize the bounding box for another dimension. In this scenario, I will be optimizing for higher precision as the coverage will be increased as the bounding box increases.</span>
<span id="cb42-961"><a href="#cb42-961" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-962"><a href="#cb42-962" aria-hidden="true" tabindex="-1"></a><span class="in">```{r greed1}</span></span>
<span id="cb42-963"><a href="#cb42-963" aria-hidden="true" tabindex="-1"></a><span class="co">#| warning: false</span></span>
<span id="cb42-964"><a href="#cb42-964" aria-hidden="true" tabindex="-1"></a><span class="co">#| message: false</span></span>
<span id="cb42-965"><a href="#cb42-965" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-966"><a href="#cb42-966" aria-hidden="true" tabindex="-1"></a><span class="co"># define final anchor to be null</span></span>
<span id="cb42-967"><a href="#cb42-967" aria-hidden="true" tabindex="-1"></a>final_anchor <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb42-968"><a href="#cb42-968" aria-hidden="true" tabindex="-1"></a>dimensions <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="st">"x"</span> <span class="ot">=</span> x_grid,<span class="st">"y"</span> <span class="ot">=</span> y_grid) <span class="co"># variable names as names</span></span>
<span id="cb42-969"><a href="#cb42-969" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">imap</span>(dimensions, <span class="cf">function</span>(bounds, var_name){</span>
<span id="cb42-970"><a href="#cb42-970" aria-hidden="true" tabindex="-1"></a>  dim_results <span class="ot">&lt;-</span> <span class="fu">future_map_dfr</span>(<span class="fu">seq_len</span>(<span class="fu">nrow</span>(bounds)), <span class="cf">function</span>(i) {</span>
<span id="cb42-971"><a href="#cb42-971" aria-hidden="true" tabindex="-1"></a>    row <span class="ot">&lt;-</span> bounds[i, ]</span>
<span id="cb42-972"><a href="#cb42-972" aria-hidden="true" tabindex="-1"></a>    lower_bound_pred <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>, <span class="at">constant =</span> row[[<span class="st">"L"</span>]])</span>
<span id="cb42-973"><a href="#cb42-973" aria-hidden="true" tabindex="-1"></a>    upper_bound_pred <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>, <span class="at">constant =</span> row[[<span class="st">"U"</span>]])</span>
<span id="cb42-974"><a href="#cb42-974" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">is.null</span>(final_anchor)) {</span>
<span id="cb42-975"><a href="#cb42-975" aria-hidden="true" tabindex="-1"></a>      bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(lower_bound_pred, upper_bound_pred))  </span>
<span id="cb42-976"><a href="#cb42-976" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb42-977"><a href="#cb42-977" aria-hidden="true" tabindex="-1"></a>      bound <span class="ot">&lt;-</span> final_anchor <span class="sc">|&gt;</span></span>
<span id="cb42-978"><a href="#cb42-978" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(lower_bound_pred) <span class="sc">|&gt;</span></span>
<span id="cb42-979"><a href="#cb42-979" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(upper_bound_pred)</span>
<span id="cb42-980"><a href="#cb42-980" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb42-981"><a href="#cb42-981" aria-hidden="true" tabindex="-1"></a>    <span class="co"># cover &lt;- coverage(bound, dist_func, n_samples = 10000)</span></span>
<span id="cb42-982"><a href="#cb42-982" aria-hidden="true" tabindex="-1"></a>    cover <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x, y))</span>
<span id="cb42-983"><a href="#cb42-983" aria-hidden="true" tabindex="-1"></a>    prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">10000</span>)</span>
<span id="cb42-984"><a href="#cb42-984" aria-hidden="true" tabindex="-1"></a>    <span class="fu">bind_cols</span>(row, <span class="fu">tibble</span>(<span class="at">cover =</span> cover, <span class="at">precision_1 =</span> prec[<span class="dv">1</span>], <span class="at">precision_2 =</span> prec[<span class="dv">2</span>]))</span>
<span id="cb42-985"><a href="#cb42-985" aria-hidden="true" tabindex="-1"></a>  }, <span class="at">.options =</span> <span class="fu">furrr_options</span>(<span class="at">globals =</span> <span class="fu">c</span>(<span class="st">"satisfies"</span>, <span class="st">"predicate"</span>, <span class="st">"anchors"</span>, <span class="st">"coverage_area"</span>, <span class="st">"precision"</span>, <span class="st">"extend"</span>, <span class="st">"final_anchor"</span>, <span class="st">"dist_func"</span>, <span class="st">"model_func"</span>, <span class="st">"dimensions"</span>, <span class="st">"samples"</span>, <span class="st">"rfmodel"</span>, <span class="st">"bind_cols"</span>, <span class="st">"train_df"</span>, <span class="st">"calculate_area"</span>)))</span>
<span id="cb42-986"><a href="#cb42-986" aria-hidden="true" tabindex="-1"></a>  max_prec <span class="ot">&lt;-</span> dim_results <span class="sc">|&gt;</span> <span class="fu">slice_max</span>(precision_1) <span class="sc">|&gt;</span> <span class="fu">head</span>(<span class="dv">1</span>)</span>
<span id="cb42-987"><a href="#cb42-987" aria-hidden="true" tabindex="-1"></a>  best_lower_bound <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>, <span class="at">constant =</span> max_prec[[<span class="st">"L"</span>]])</span>
<span id="cb42-988"><a href="#cb42-988" aria-hidden="true" tabindex="-1"></a>  best_upper_bound <span class="ot">&lt;-</span> <span class="fu">predicate</span>(<span class="at">feature =</span> var_name, <span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>, <span class="at">constant =</span> max_prec[[<span class="st">"U"</span>]])</span>
<span id="cb42-989"><a href="#cb42-989" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(final_anchor)) {</span>
<span id="cb42-990"><a href="#cb42-990" aria-hidden="true" tabindex="-1"></a>    final_anchor <span class="ot">&lt;&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(best_lower_bound, best_upper_bound))  </span>
<span id="cb42-991"><a href="#cb42-991" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb42-992"><a href="#cb42-992" aria-hidden="true" tabindex="-1"></a>    final_anchor <span class="ot">&lt;&lt;-</span> final_anchor <span class="sc">|&gt;</span></span>
<span id="cb42-993"><a href="#cb42-993" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(best_lower_bound) <span class="sc">|&gt;</span></span>
<span id="cb42-994"><a href="#cb42-994" aria-hidden="true" tabindex="-1"></a>        <span class="fu">extend</span>(best_upper_bound)</span>
<span id="cb42-995"><a href="#cb42-995" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-996"><a href="#cb42-996" aria-hidden="true" tabindex="-1"></a>  <span class="fu">list</span>(<span class="at">res =</span> dim_results, <span class="at">lb =</span> best_lower_bound, <span class="at">ub =</span> best_upper_bound)</span>
<span id="cb42-997"><a href="#cb42-997" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb42-998"><a href="#cb42-998" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-999"><a href="#cb42-999" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1000"><a href="#cb42-1000" aria-hidden="true" tabindex="-1"></a>The coverage and precision plots for the x and y dimensions are visualized below. </span>
<span id="cb42-1001"><a href="#cb42-1001" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1004"><a href="#cb42-1004" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-1005"><a href="#cb42-1005" aria-hidden="true" tabindex="-1"></a>x_cov_prec_plot <span class="ot">&lt;-</span> results<span class="sc">$</span>x<span class="sc">$</span>res <span class="sc">|&gt;</span></span>
<span id="cb42-1006"><a href="#cb42-1006" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> precision_1, <span class="at">y =</span> cover)) <span class="sc">+</span> </span>
<span id="cb42-1007"><a href="#cb42-1007" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">alpha =</span> <span class="fl">0.75</span>) <span class="sc">+</span></span>
<span id="cb42-1008"><a href="#cb42-1008" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb42-1009"><a href="#cb42-1009" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for the x axis"</span>,</span>
<span id="cb42-1010"><a href="#cb42-1010" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb42-1011"><a href="#cb42-1011" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb42-1012"><a href="#cb42-1012" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-1013"><a href="#cb42-1013" aria-hidden="true" tabindex="-1"></a>y_cov_prec_plot <span class="ot">&lt;-</span> results<span class="sc">$</span>y<span class="sc">$</span>res <span class="sc">|&gt;</span></span>
<span id="cb42-1014"><a href="#cb42-1014" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> precision_1, <span class="at">y =</span> cover)) <span class="sc">+</span></span>
<span id="cb42-1015"><a href="#cb42-1015" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">size =</span> <span class="fl">0.5</span>, <span class="at">alpha =</span> <span class="fl">0.75</span>) <span class="sc">+</span></span>
<span id="cb42-1016"><a href="#cb42-1016" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">xintercept =</span> <span class="fl">0.8</span>) <span class="sc">+</span></span>
<span id="cb42-1017"><a href="#cb42-1017" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb42-1018"><a href="#cb42-1018" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"Precision vs Coverage for the y axis"</span>,</span>
<span id="cb42-1019"><a href="#cb42-1019" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Precision"</span>,</span>
<span id="cb42-1020"><a href="#cb42-1020" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"Coverage"</span></span>
<span id="cb42-1021"><a href="#cb42-1021" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-1022"><a href="#cb42-1022" aria-hidden="true" tabindex="-1"></a>x_cov_prec_plot <span class="sc">|</span> y_cov_prec_plot</span>
<span id="cb42-1023"><a href="#cb42-1023" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1024"><a href="#cb42-1024" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1025"><a href="#cb42-1025" aria-hidden="true" tabindex="-1"></a>In the above plot there is a similar pattern to the one dimensional example of cascading points. Interestingly, precision are coverage have a non linear positive relationship in the bounding boxes in the $x$ axis. After fixing the $x$ axis, changing the $y$ axis bounding box creates a non linear negative relationship between precision and coverage. This can also provide insights into how the model boundary is defined around the local instance.</span>
<span id="cb42-1026"><a href="#cb42-1026" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1027"><a href="#cb42-1027" aria-hidden="true" tabindex="-1"></a>The bounding box with the highest precision is as follows.</span>
<span id="cb42-1028"><a href="#cb42-1028" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1031"><a href="#cb42-1031" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-1032"><a href="#cb42-1032" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: true</span></span>
<span id="cb42-1033"><a href="#cb42-1033" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1034"><a href="#cb42-1034" aria-hidden="true" tabindex="-1"></a>train_df[<span class="sc">-</span>local_instance, ] <span class="sc">|&gt;</span></span>
<span id="cb42-1035"><a href="#cb42-1035" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb42-1036"><a href="#cb42-1036" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-1037"><a href="#cb42-1037" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">size =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb42-1038"><a href="#cb42-1038" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.05</span>) <span class="sc">+</span></span>
<span id="cb42-1039"><a href="#cb42-1039" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_rect</span>(<span class="at">inherit.aes =</span> F, </span>
<span id="cb42-1040"><a href="#cb42-1040" aria-hidden="true" tabindex="-1"></a>            <span class="at">data =</span> <span class="fu">tibble</span>(<span class="at">x_lb =</span> results<span class="sc">$</span>x<span class="sc">$</span>lb<span class="sc">@</span>constant,</span>
<span id="cb42-1041"><a href="#cb42-1041" aria-hidden="true" tabindex="-1"></a>                          <span class="at">y_lb =</span> results<span class="sc">$</span>y<span class="sc">$</span>lb<span class="sc">@</span>constant,</span>
<span id="cb42-1042"><a href="#cb42-1042" aria-hidden="true" tabindex="-1"></a>                          <span class="at">x_ub =</span> results<span class="sc">$</span>x<span class="sc">$</span>ub<span class="sc">@</span>constant,</span>
<span id="cb42-1043"><a href="#cb42-1043" aria-hidden="true" tabindex="-1"></a>                          <span class="at">y_ub =</span> results<span class="sc">$</span>y<span class="sc">$</span>ub<span class="sc">@</span>constant),</span>
<span id="cb42-1044"><a href="#cb42-1044" aria-hidden="true" tabindex="-1"></a>            <span class="fu">aes</span>(<span class="at">xmin =</span> x_lb, <span class="at">xmax =</span> x_ub, <span class="at">ymin =</span> y_lb, <span class="at">ymax =</span> y_ub), <span class="at">fill =</span> <span class="st">"transparent"</span>, <span class="at">color =</span> <span class="st">"black"</span>)</span>
<span id="cb42-1045"><a href="#cb42-1045" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1046"><a href="#cb42-1046" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1047"><a href="#cb42-1047" aria-hidden="true" tabindex="-1"></a><span class="fu">## Remarks on sequential brute force approach</span></span>
<span id="cb42-1048"><a href="#cb42-1048" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1049"><a href="#cb42-1049" aria-hidden="true" tabindex="-1"></a>The sequential brute force approach has proven to be effective in deriving an ideal bounding box. However, it is quite time consuming and might not generalize well for higher dimensions. An alternate approach would be to sample bounding boxes along each dimension and sequentially plot the precision and coverage for select points to glean insights into the model boundary around the given instance.</span>
<span id="cb42-1050"><a href="#cb42-1050" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1051"><a href="#cb42-1051" aria-hidden="true" tabindex="-1"></a><span class="fu">## Simple Multi-arm Bandits solution using Upper Confidence Bounds in two dimensions {#sec-mab-twod}</span></span>
<span id="cb42-1052"><a href="#cb42-1052" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1053"><a href="#cb42-1053" aria-hidden="true" tabindex="-1"></a>The sequential greedy method does seem to be generating good boundaries. However, to be faithful to the original paper, and to explore the benefits of using a multi-arm bandit solution, let us try modelling this as a multi-arm bandit problem. I will define the possible choices as increasing the lower or upper bound of each dimension, resulting in four arms that can be pulled. The reward in this case would be a combination of the precision and the coverage with penalties associated for taking a wrong direction.</span>
<span id="cb42-1054"><a href="#cb42-1054" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1055"><a href="#cb42-1055" aria-hidden="true" tabindex="-1"></a>To put it simply imagine you are the local point and you are trying to find similar friends like yourself by pushing a wall around you. Your options are to either push the north, east, west, or south walls to find new friends. When you increase the walls you get rewarded and when you find like minded friends you get rewarded as well.</span>
<span id="cb42-1056"><a href="#cb42-1056" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1057"><a href="#cb42-1057" aria-hidden="true" tabindex="-1"></a>We will be simulating several games and each game will have several rounds within them. The idea is to by the end of the simulation have a strategy on which actions to prioritize when generating the ideal boundary.</span>
<span id="cb42-1058"><a href="#cb42-1058" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1061"><a href="#cb42-1061" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-1062"><a href="#cb42-1062" aria-hidden="true" tabindex="-1"></a>envir <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb42-1063"><a href="#cb42-1063" aria-hidden="true" tabindex="-1"></a>  <span class="at">x_lb =</span> x_grid<span class="sc">$</span>L,</span>
<span id="cb42-1064"><a href="#cb42-1064" aria-hidden="true" tabindex="-1"></a>  <span class="at">x_ub =</span> x_grid<span class="sc">$</span>U,</span>
<span id="cb42-1065"><a href="#cb42-1065" aria-hidden="true" tabindex="-1"></a>  <span class="at">y_lb =</span> y_grid<span class="sc">$</span>L,</span>
<span id="cb42-1066"><a href="#cb42-1066" aria-hidden="true" tabindex="-1"></a>  <span class="at">y_ub =</span> y_grid<span class="sc">$</span>U</span>
<span id="cb42-1067"><a href="#cb42-1067" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb42-1068"><a href="#cb42-1068" aria-hidden="true" tabindex="-1"></a>actions <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"x_lb"</span>, <span class="st">"x_ub"</span>, <span class="st">"y_lb"</span>, <span class="st">"y_ub"</span>)</span>
<span id="cb42-1069"><a href="#cb42-1069" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1070"><a href="#cb42-1070" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1071"><a href="#cb42-1071" aria-hidden="true" tabindex="-1"></a>In this scenario we will be using a modified Upper Confidence Bound algorithm <span class="co">[</span><span class="ot">@timmiller_introduction_rl</span><span class="co">]</span> to find solutions to the multi-arm bandit problem</span>
<span id="cb42-1072"><a href="#cb42-1072" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1073"><a href="#cb42-1073" aria-hidden="true" tabindex="-1"></a><span class="fu">### Modified Upper Confidence Bound algorithm {#sec-ucb-algo}</span></span>
<span id="cb42-1074"><a href="#cb42-1074" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1075"><a href="#cb42-1075" aria-hidden="true" tabindex="-1"></a>The reward can be defined as follows,</span>
<span id="cb42-1076"><a href="#cb42-1076" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1077"><a href="#cb42-1077" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-1078"><a href="#cb42-1078" aria-hidden="true" tabindex="-1"></a>\begin{equation}</span>
<span id="cb42-1079"><a href="#cb42-1079" aria-hidden="true" tabindex="-1"></a>R(\mathcal{A}) =</span>
<span id="cb42-1080"><a href="#cb42-1080" aria-hidden="true" tabindex="-1"></a>    \begin{cases}</span>
<span id="cb42-1081"><a href="#cb42-1081" aria-hidden="true" tabindex="-1"></a>        \text{Prec}(\mathcal{A}) + \text{cov}(\mathcal{A})^2 &amp; \text{if } \text{Prec}(\mathcal{A}) \in \mathbb{R} <span class="sc">\\</span></span>
<span id="cb42-1082"><a href="#cb42-1082" aria-hidden="true" tabindex="-1"></a>        -9999 &amp; \text{if } \text{Prec}(\mathcal{A}) \notin \mathbb{R} <span class="sc">\\</span></span>
<span id="cb42-1083"><a href="#cb42-1083" aria-hidden="true" tabindex="-1"></a>        -9999 &amp; \text{if } \text{Prec}(\mathcal{A}) &lt; 0.6 </span>
<span id="cb42-1084"><a href="#cb42-1084" aria-hidden="true" tabindex="-1"></a>    \end{cases}</span>
<span id="cb42-1085"><a href="#cb42-1085" aria-hidden="true" tabindex="-1"></a>\end{equation}</span>
<span id="cb42-1086"><a href="#cb42-1086" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-1087"><a href="#cb42-1087" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1088"><a href="#cb42-1088" aria-hidden="true" tabindex="-1"></a>The reasoning for the large negative numbers is to induce a heavy penalty if the precision is not a real number (or null in this case) as there might be boundaries that would be explored which might not contain enough samples from the perturbation distribution to explore, or if the precision is a low number indicating that the model is uncertain of the results. </span>
<span id="cb42-1089"><a href="#cb42-1089" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1090"><a href="#cb42-1090" aria-hidden="true" tabindex="-1"></a>Meanwhile the next action $a$ that we select for each iteration is based on the following statement</span>
<span id="cb42-1091"><a href="#cb42-1091" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1092"><a href="#cb42-1092" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-1093"><a href="#cb42-1093" aria-hidden="true" tabindex="-1"></a>a = \underset{a}{\mathrm{argmax }} Q^*(a) + Q(a) + \sqrt{\frac{2 \cdot ln(g)}{N(a)}}</span>
<span id="cb42-1094"><a href="#cb42-1094" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb42-1095"><a href="#cb42-1095" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1096"><a href="#cb42-1096" aria-hidden="true" tabindex="-1"></a>Here $N(a)$ is the number of times $a$ has been selected as the next action in the course of a given game, $Q(a)$ is the cumulative average reward gain for each action in the given round, while $Q^*(a)$ is the average of $Q(a)$ across games. The terms in the square root encourages exploration by being high for actions that have been explored less – that is, when $N(a)$ is low relative to other actions while the terms with $Q(\cdot)$ encourages exploitation of known rewards. Notice that in the beginning of each round $N(a) = 0$ for all actions and therefore we would first running a few warmup rounds until we have enough values in $N(a)$ to have atleast one positive value for $Q(a)$. </span>
<span id="cb42-1097"><a href="#cb42-1097" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1098"><a href="#cb42-1098" aria-hidden="true" tabindex="-1"></a>Also note the UCB algorithm offers a balance between exploration and exploitation which is contrastingly different from the KL-LUCB algorithm which is a pure exploration strategy. In a lower dimensional setting a pure exploration method would be no different from a brute force approach and therefore I believe for this explanation to be more intuitive we should be incorporating knowledge between games and exploiting known successful solutions.</span>
<span id="cb42-1099"><a href="#cb42-1099" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1102"><a href="#cb42-1102" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-1103"><a href="#cb42-1103" aria-hidden="true" tabindex="-1"></a>get_reward <span class="ot">&lt;-</span> <span class="cf">function</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func, <span class="at">class_ind =</span> <span class="dv">1</span>) {</span>
<span id="cb42-1104"><a href="#cb42-1104" aria-hidden="true" tabindex="-1"></a>  bound <span class="ot">&lt;-</span> <span class="fu">anchors</span>(<span class="fu">c</span>(</span>
<span id="cb42-1105"><a href="#cb42-1105" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>x_lb[x_lb_ind]),</span>
<span id="cb42-1106"><a href="#cb42-1106" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"x"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>x_ub[x_ub_ind]),</span>
<span id="cb42-1107"><a href="#cb42-1107" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"y"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&gt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>y_lb[y_lb_ind]),</span>
<span id="cb42-1108"><a href="#cb42-1108" aria-hidden="true" tabindex="-1"></a>    <span class="fu">predicate</span>(<span class="at">feature =</span> <span class="st">"y"</span>,<span class="at">operator =</span> <span class="st">`</span><span class="at">&lt;</span><span class="st">`</span>,<span class="at">constant =</span> envir<span class="sc">$</span>y_ub[y_ub_ind])</span>
<span id="cb42-1109"><a href="#cb42-1109" aria-hidden="true" tabindex="-1"></a>  ))</span>
<span id="cb42-1110"><a href="#cb42-1110" aria-hidden="true" tabindex="-1"></a>  <span class="co"># cover &lt;- coverage(bound, dist_func, n_samples = 10000)</span></span>
<span id="cb42-1111"><a href="#cb42-1111" aria-hidden="true" tabindex="-1"></a>  cover <span class="ot">&lt;-</span> <span class="fu">coverage_area</span>(bound, train_df <span class="sc">|&gt;</span> <span class="fu">select</span>(x, y))</span>
<span id="cb42-1112"><a href="#cb42-1112" aria-hidden="true" tabindex="-1"></a>  prec <span class="ot">&lt;-</span> <span class="fu">precision</span>(bound, model_func, dist_func, <span class="at">n_samples =</span> <span class="dv">10000</span>)</span>
<span id="cb42-1113"><a href="#cb42-1113" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">is.null</span>(prec)) <span class="fu">return</span>(<span class="sc">-</span><span class="dv">9999</span>) <span class="co"># penalty</span></span>
<span id="cb42-1114"><a href="#cb42-1114" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(prec[class_ind] <span class="sc">&lt;</span> <span class="fl">0.6</span>) {</span>
<span id="cb42-1115"><a href="#cb42-1115" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>(<span class="sc">-</span><span class="dv">9999</span>) <span class="co"># penalty for wrong direction</span></span>
<span id="cb42-1116"><a href="#cb42-1116" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-1117"><a href="#cb42-1117" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"reward precision {round(prec[class_ind], 2)} and coverage {round(cover, 2)}"</span>))</span>
<span id="cb42-1118"><a href="#cb42-1118" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(prec[class_ind] <span class="sc">+</span> (cover <span class="sc">^</span> <span class="dv">2</span>))</span>
<span id="cb42-1119"><a href="#cb42-1119" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-1120"><a href="#cb42-1120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1121"><a href="#cb42-1121" aria-hidden="true" tabindex="-1"></a>select_action <span class="ot">&lt;-</span> <span class="cf">function</span>(Q, N, n_game) {</span>
<span id="cb42-1122"><a href="#cb42-1122" aria-hidden="true" tabindex="-1"></a>  rewards <span class="ot">&lt;-</span> <span class="fu">map_dbl</span>(actions, <span class="cf">function</span>(a){</span>
<span id="cb42-1123"><a href="#cb42-1123" aria-hidden="true" tabindex="-1"></a>    Q_star[[a]] <span class="sc">+</span> Q[[a]] <span class="sc">+</span> <span class="fu">sqrt</span>((<span class="dv">2</span> <span class="sc">*</span> <span class="fu">log</span>(n_game)) <span class="sc">/</span> N[[a]])</span>
<span id="cb42-1124"><a href="#cb42-1124" aria-hidden="true" tabindex="-1"></a>  })</span>
<span id="cb42-1125"><a href="#cb42-1125" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"selection criteria {paste(round(rewards,2), collapse = ',')}"</span>))</span>
<span id="cb42-1126"><a href="#cb42-1126" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="fu">sum</span>(rewards <span class="sc">==</span> <span class="fu">max</span>(rewards)) <span class="sc">&gt;</span> <span class="dv">1</span>) {</span>
<span id="cb42-1127"><a href="#cb42-1127" aria-hidden="true" tabindex="-1"></a>    max_reward <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">which</span>(rewards <span class="sc">==</span> <span class="fu">max</span>(rewards)), <span class="dv">1</span>)</span>
<span id="cb42-1128"><a href="#cb42-1128" aria-hidden="true" tabindex="-1"></a>  } <span class="cf">else</span> {</span>
<span id="cb42-1129"><a href="#cb42-1129" aria-hidden="true" tabindex="-1"></a>    max_reward <span class="ot">&lt;-</span> <span class="fu">which.max</span>(rewards)  </span>
<span id="cb42-1130"><a href="#cb42-1130" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-1131"><a href="#cb42-1131" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(actions[max_reward])</span>
<span id="cb42-1132"><a href="#cb42-1132" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-1133"><a href="#cb42-1133" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1134"><a href="#cb42-1134" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1135"><a href="#cb42-1135" aria-hidden="true" tabindex="-1"></a>Similar to the sequential greedy approach, I will be defining a model function and perturbation distribution.</span>
<span id="cb42-1136"><a href="#cb42-1136" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1139"><a href="#cb42-1139" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-1140"><a href="#cb42-1140" aria-hidden="true" tabindex="-1"></a>pertub_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) {</span>
<span id="cb42-1141"><a href="#cb42-1141" aria-hidden="true" tabindex="-1"></a>  mulgar<span class="sc">::</span><span class="fu">rmvn</span>(<span class="at">n =</span> n, </span>
<span id="cb42-1142"><a href="#cb42-1142" aria-hidden="true" tabindex="-1"></a>               <span class="at">p =</span> <span class="dv">2</span>,</span>
<span id="cb42-1143"><a href="#cb42-1143" aria-hidden="true" tabindex="-1"></a>               <span class="at">mn =</span> train_df[local_instance, <span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)] <span class="sc">|&gt;</span> </span>
<span id="cb42-1144"><a href="#cb42-1144" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">unlist</span>(),</span>
<span id="cb42-1145"><a href="#cb42-1145" aria-hidden="true" tabindex="-1"></a>               <span class="at">vc =</span> <span class="fu">cov</span>(train_df[,<span class="fu">c</span>(<span class="st">"x"</span>, <span class="st">"y"</span>)])</span>
<span id="cb42-1146"><a href="#cb42-1146" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">|&gt;</span></span>
<span id="cb42-1147"><a href="#cb42-1147" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.data.frame</span>() <span class="sc">|&gt;</span></span>
<span id="cb42-1148"><a href="#cb42-1148" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rename</span>(<span class="at">x =</span> x1, <span class="at">y =</span> x2)</span>
<span id="cb42-1149"><a href="#cb42-1149" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-1150"><a href="#cb42-1150" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1151"><a href="#cb42-1151" aria-hidden="true" tabindex="-1"></a>model_func <span class="ot">&lt;-</span> <span class="cf">function</span>(data_samples) {</span>
<span id="cb42-1152"><a href="#cb42-1152" aria-hidden="true" tabindex="-1"></a>  <span class="fu">suppressPackageStartupMessages</span>(<span class="fu">library</span>(randomForest)) <span class="co"># for future package</span></span>
<span id="cb42-1153"><a href="#cb42-1153" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">predict</span>(rfmodel, data_samples))</span>
<span id="cb42-1154"><a href="#cb42-1154" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-1155"><a href="#cb42-1155" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1156"><a href="#cb42-1156" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb42-1157"><a href="#cb42-1157" aria-hidden="true" tabindex="-1"></a>samples <span class="ot">&lt;-</span> <span class="fu">pertub_func</span>(<span class="at">n =</span> <span class="dv">10000</span>)</span>
<span id="cb42-1158"><a href="#cb42-1158" aria-hidden="true" tabindex="-1"></a>dist_func <span class="ot">&lt;-</span> <span class="cf">function</span>(n) samples[<span class="dv">1</span><span class="sc">:</span>n, ]</span>
<span id="cb42-1159"><a href="#cb42-1159" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1160"><a href="#cb42-1160" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1161"><a href="#cb42-1161" aria-hidden="true" tabindex="-1"></a>I will be simulating 5 games with each game containing 100 rounds. An interesting component to the following algorithm is that if I draw an action that gives me a penalty after the warmup period I would undo that action and move on to the next round. This would further ensure that the model does not explore actions that are not beneficial for the reward.</span>
<span id="cb42-1162"><a href="#cb42-1162" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1165"><a href="#cb42-1165" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-1166"><a href="#cb42-1166" aria-hidden="true" tabindex="-1"></a>n_games <span class="ot">&lt;-</span> <span class="dv">5</span></span>
<span id="cb42-1167"><a href="#cb42-1167" aria-hidden="true" tabindex="-1"></a>n_epochs <span class="ot">&lt;-</span> <span class="dv">100</span></span>
<span id="cb42-1168"><a href="#cb42-1168" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1169"><a href="#cb42-1169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1170"><a href="#cb42-1170" aria-hidden="true" tabindex="-1"></a><span class="in">```{r mab1}</span></span>
<span id="cb42-1171"><a href="#cb42-1171" aria-hidden="true" tabindex="-1"></a><span class="co">#| eval: !expr "!file.exists(here::here('scratchpad/assignment_state_plot_1.gif'))"</span></span>
<span id="cb42-1172"><a href="#cb42-1172" aria-hidden="true" tabindex="-1"></a><span class="co">#| output: false</span></span>
<span id="cb42-1173"><a href="#cb42-1173" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1174"><a href="#cb42-1174" aria-hidden="true" tabindex="-1"></a>Q_star <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">x_ub =</span> <span class="dv">0</span>, <span class="at">y_ub =</span> <span class="dv">0</span>, <span class="at">x_lb =</span> <span class="dv">0</span>, <span class="at">y_lb =</span> <span class="dv">0</span>)</span>
<span id="cb42-1175"><a href="#cb42-1175" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(game <span class="cf">in</span> <span class="fu">seq_len</span>(n_games)) {</span>
<span id="cb42-1176"><a href="#cb42-1176" aria-hidden="true" tabindex="-1"></a>  cli<span class="sc">::</span><span class="fu">cli_h1</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Starting game {game}"</span>))</span>
<span id="cb42-1177"><a href="#cb42-1177" aria-hidden="true" tabindex="-1"></a>  x_ub_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb42-1178"><a href="#cb42-1178" aria-hidden="true" tabindex="-1"></a>  x_lb_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb42-1179"><a href="#cb42-1179" aria-hidden="true" tabindex="-1"></a>  y_ub_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb42-1180"><a href="#cb42-1180" aria-hidden="true" tabindex="-1"></a>  y_lb_ind <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb42-1181"><a href="#cb42-1181" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">x_ub =</span> <span class="dv">0</span>, <span class="at">y_ub =</span> <span class="dv">0</span>, <span class="at">x_lb =</span> <span class="dv">0</span>, <span class="at">y_lb =</span> <span class="dv">0</span>)</span>
<span id="cb42-1182"><a href="#cb42-1182" aria-hidden="true" tabindex="-1"></a>  Q <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">x_ub =</span> <span class="dv">0</span>, <span class="at">y_ub =</span> <span class="dv">0</span>, <span class="at">x_lb =</span> <span class="dv">0</span>, <span class="at">y_lb =</span> <span class="dv">0</span>)</span>
<span id="cb42-1183"><a href="#cb42-1183" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb42-1184"><a href="#cb42-1184" aria-hidden="true" tabindex="-1"></a>  <span class="co"># initial round to explore all arms</span></span>
<span id="cb42-1185"><a href="#cb42-1185" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span>(<span class="fu">all</span>(Q <span class="sc">|&gt;</span> <span class="fu">map_lgl</span>(<span class="sc">~</span> .x <span class="sc">&lt;=</span> <span class="dv">0</span>))) {</span>
<span id="cb42-1186"><a href="#cb42-1186" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span>(action <span class="cf">in</span> actions) {</span>
<span id="cb42-1187"><a href="#cb42-1187" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_ub"</span>) x_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_ub), x_ub_ind, x_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1188"><a href="#cb42-1188" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_ub"</span>) y_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_ub), y_ub_ind, y_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1189"><a href="#cb42-1189" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_lb"</span>) x_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_lb), x_lb_ind, x_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1190"><a href="#cb42-1190" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_lb"</span>) y_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_lb), y_lb_ind, y_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1191"><a href="#cb42-1191" aria-hidden="true" tabindex="-1"></a>      reward <span class="ot">&lt;-</span> <span class="fu">get_reward</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func)</span>
<span id="cb42-1192"><a href="#cb42-1192" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb42-1193"><a href="#cb42-1193" aria-hidden="true" tabindex="-1"></a>      reward <span class="ot">&lt;-</span> <span class="fu">get_reward</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func)</span>
<span id="cb42-1194"><a href="#cb42-1194" aria-hidden="true" tabindex="-1"></a>      N[[action]] <span class="ot">&lt;-</span> N[[action]] <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb42-1195"><a href="#cb42-1195" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(Q[[action]] <span class="sc">&lt;=</span> <span class="dv">0</span> <span class="sc">&amp;&amp;</span> reward <span class="sc">&gt;=</span> <span class="dv">0</span>) {</span>
<span id="cb42-1196"><a href="#cb42-1196" aria-hidden="true" tabindex="-1"></a>        Q[[action]] <span class="ot">&lt;-</span> reward</span>
<span id="cb42-1197"><a href="#cb42-1197" aria-hidden="true" tabindex="-1"></a>      } <span class="cf">else</span> {</span>
<span id="cb42-1198"><a href="#cb42-1198" aria-hidden="true" tabindex="-1"></a>        Q[[action]] <span class="ot">&lt;-</span> Q[[action]] <span class="sc">+</span> ((reward <span class="sc">-</span> Q[[action]]) <span class="sc">/</span> N[[action]])  </span>
<span id="cb42-1199"><a href="#cb42-1199" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb42-1200"><a href="#cb42-1200" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Q : {paste(Q, collapse = ',')} N: {paste(N, collapse = ',')}"</span>))</span>
<span id="cb42-1201"><a href="#cb42-1201" aria-hidden="true" tabindex="-1"></a>    }  </span>
<span id="cb42-1202"><a href="#cb42-1202" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-1203"><a href="#cb42-1203" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb42-1204"><a href="#cb42-1204" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(epoch <span class="cf">in</span> <span class="fu">seq_len</span>(n_epochs)) {</span>
<span id="cb42-1205"><a href="#cb42-1205" aria-hidden="true" tabindex="-1"></a>    cli<span class="sc">::</span><span class="fu">cli_h2</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Starting epoch {epoch}"</span>))</span>
<span id="cb42-1206"><a href="#cb42-1206" aria-hidden="true" tabindex="-1"></a>    action <span class="ot">&lt;-</span> <span class="fu">select_action</span>(Q, N, game)</span>
<span id="cb42-1207"><a href="#cb42-1207" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-1208"><a href="#cb42-1208" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_ub"</span>) x_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_ub), x_ub_ind, x_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1209"><a href="#cb42-1209" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_ub"</span>) y_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_ub_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_ub), y_ub_ind, y_ub_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1210"><a href="#cb42-1210" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_lb"</span>) x_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>x_lb), x_lb_ind, x_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1211"><a href="#cb42-1211" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_lb"</span>) y_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_lb_ind <span class="sc">==</span> <span class="fu">length</span>(envir<span class="sc">$</span>y_lb), y_lb_ind, y_lb_ind <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb42-1212"><a href="#cb42-1212" aria-hidden="true" tabindex="-1"></a>    reward <span class="ot">&lt;-</span> <span class="fu">get_reward</span>(x_lb_ind, x_ub_ind, y_lb_ind, y_ub_ind, dist_func, model_func)</span>
<span id="cb42-1213"><a href="#cb42-1213" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb42-1214"><a href="#cb42-1214" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(reward <span class="sc">&lt;</span> <span class="dv">0</span>) {</span>
<span id="cb42-1215"><a href="#cb42-1215" aria-hidden="true" tabindex="-1"></a>      <span class="co"># if a penalty was received </span></span>
<span id="cb42-1216"><a href="#cb42-1216" aria-hidden="true" tabindex="-1"></a>      <span class="co"># we undo the action and go on with the rest</span></span>
<span id="cb42-1217"><a href="#cb42-1217" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_ub"</span>) x_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_ub_ind <span class="sc">==</span> <span class="dv">1</span>, x_ub_ind, x_ub_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb42-1218"><a href="#cb42-1218" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_ub"</span>) y_ub_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_ub_ind <span class="sc">==</span> <span class="dv">1</span>, y_ub_ind, y_ub_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb42-1219"><a href="#cb42-1219" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"x_lb"</span>) x_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(x_lb_ind <span class="sc">==</span> <span class="dv">1</span>, x_lb_ind, x_lb_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb42-1220"><a href="#cb42-1220" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span>(action <span class="sc">==</span> <span class="st">"y_lb"</span>) y_lb_ind <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(y_lb_ind <span class="sc">==</span> <span class="dv">1</span>, y_lb_ind, y_lb_ind <span class="sc">-</span> <span class="dv">1</span>)</span>
<span id="cb42-1221"><a href="#cb42-1221" aria-hidden="true" tabindex="-1"></a>      <span class="cf">next</span></span>
<span id="cb42-1222"><a href="#cb42-1222" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb42-1223"><a href="#cb42-1223" aria-hidden="true" tabindex="-1"></a>    N[[action]] <span class="ot">&lt;-</span> N[[action]] <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb42-1224"><a href="#cb42-1224" aria-hidden="true" tabindex="-1"></a>    Q[[action]] <span class="ot">&lt;-</span> Q[[action]] <span class="sc">+</span> ((reward <span class="sc">-</span> Q[[action]]) <span class="sc">/</span> N[[action]])</span>
<span id="cb42-1225"><a href="#cb42-1225" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span>(glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Q : {paste(Q, collapse = ',')} N: {paste(N, collapse = ',')}"</span>))</span>
<span id="cb42-1226"><a href="#cb42-1226" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span>(epoch <span class="sc">%%</span> <span class="dv">10</span> <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb42-1227"><a href="#cb42-1227" aria-hidden="true" tabindex="-1"></a>      state_plot <span class="ot">&lt;-</span> train_df[<span class="sc">-</span>local_instance, ] <span class="sc">|&gt;</span></span>
<span id="cb42-1228"><a href="#cb42-1228" aria-hidden="true" tabindex="-1"></a>        <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> x,<span class="at">y =</span> y,<span class="at">color =</span> class)) <span class="sc">+</span></span>
<span id="cb42-1229"><a href="#cb42-1229" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_point</span>() <span class="sc">+</span></span>
<span id="cb42-1230"><a href="#cb42-1230" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_point</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">size =</span> <span class="dv">1</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb42-1231"><a href="#cb42-1231" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_label</span>(<span class="at">data =</span> train_df[local_instance, ], <span class="at">label =</span> <span class="st">"Here"</span>, <span class="at">color =</span> <span class="st">"black"</span>, <span class="at">nudge_y =</span> <span class="fl">0.05</span>) <span class="sc">+</span></span>
<span id="cb42-1232"><a href="#cb42-1232" aria-hidden="true" tabindex="-1"></a>        <span class="fu">geom_rect</span>(<span class="at">inherit.aes =</span> F,</span>
<span id="cb42-1233"><a href="#cb42-1233" aria-hidden="true" tabindex="-1"></a>                  <span class="at">data =</span> <span class="fu">tibble</span>(<span class="at">x_lb =</span> envir<span class="sc">$</span>x_lb[x_lb_ind],</span>
<span id="cb42-1234"><a href="#cb42-1234" aria-hidden="true" tabindex="-1"></a>                                <span class="at">y_lb =</span> envir<span class="sc">$</span>y_lb[y_lb_ind],</span>
<span id="cb42-1235"><a href="#cb42-1235" aria-hidden="true" tabindex="-1"></a>                                <span class="at">x_ub =</span> envir<span class="sc">$</span>x_ub[x_ub_ind],</span>
<span id="cb42-1236"><a href="#cb42-1236" aria-hidden="true" tabindex="-1"></a>                                <span class="at">y_ub =</span> envir<span class="sc">$</span>y_ub[y_ub_ind]),</span>
<span id="cb42-1237"><a href="#cb42-1237" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">aes</span>(<span class="at">xmin =</span> x_lb, <span class="at">xmax =</span> x_ub, <span class="at">ymin =</span> y_lb, <span class="at">ymax =</span> y_ub), <span class="at">fill =</span> <span class="st">"transparent"</span>, <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb42-1238"><a href="#cb42-1238" aria-hidden="true" tabindex="-1"></a>        <span class="fu">labs</span>(<span class="at">title =</span> glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"Game: {game}, round: {epoch}, reward: {reward}"</span>))</span>
<span id="cb42-1239"><a href="#cb42-1239" aria-hidden="true" tabindex="-1"></a>      <span class="fu">ggsave</span>(<span class="at">plot =</span> state_plot,</span>
<span id="cb42-1240"><a href="#cb42-1240" aria-hidden="true" tabindex="-1"></a>             <span class="at">filename =</span> here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_dump_1/"</span>, glue<span class="sc">::</span><span class="fu">glue</span>(<span class="st">"{game}_{epoch}.png"</span>)),</span>
<span id="cb42-1241"><a href="#cb42-1241" aria-hidden="true" tabindex="-1"></a>             <span class="at">device =</span> <span class="st">"png"</span>, <span class="at">bg =</span> <span class="st">"white"</span>, <span class="at">width =</span> <span class="dv">11</span>, <span class="at">height =</span> <span class="dv">8</span>, <span class="at">units =</span> <span class="st">"in"</span>)</span>
<span id="cb42-1242"><a href="#cb42-1242" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb42-1243"><a href="#cb42-1243" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb42-1244"><a href="#cb42-1244" aria-hidden="true" tabindex="-1"></a>  Q_star <span class="ot">&lt;&lt;-</span> <span class="fu">imap</span>(Q, <span class="cf">function</span>(val, name) {(Q_star[[name]] <span class="sc">+</span> val) <span class="sc">/</span> n_games})</span>
<span id="cb42-1245"><a href="#cb42-1245" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-1246"><a href="#cb42-1246" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1247"><a href="#cb42-1247" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1248"><a href="#cb42-1248" aria-hidden="true" tabindex="-1"></a>The results of the simulations are given in the following animation. Notice that after a certain rounds of games the algorithm begins to follow the same pattern many times indicating that it has settled to a local optima and therefore would be following that procedure.</span>
<span id="cb42-1249"><a href="#cb42-1249" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1252"><a href="#cb42-1252" aria-hidden="true" tabindex="-1"></a><span class="in">```{r}</span></span>
<span id="cb42-1253"><a href="#cb42-1253" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span>(<span class="sc">!</span><span class="fu">file.exists</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_1.gif"</span>))){</span>
<span id="cb42-1254"><a href="#cb42-1254" aria-hidden="true" tabindex="-1"></a>  gifski<span class="sc">::</span><span class="fu">gifski</span>(</span>
<span id="cb42-1255"><a href="#cb42-1255" aria-hidden="true" tabindex="-1"></a>    <span class="at">png_files =</span> <span class="fu">list.files</span>(</span>
<span id="cb42-1256"><a href="#cb42-1256" aria-hidden="true" tabindex="-1"></a>      here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_dump_1/"</span>),</span>
<span id="cb42-1257"><a href="#cb42-1257" aria-hidden="true" tabindex="-1"></a>      <span class="at">full.names =</span> <span class="cn">TRUE</span></span>
<span id="cb42-1258"><a href="#cb42-1258" aria-hidden="true" tabindex="-1"></a>    ) <span class="sc">|&gt;</span> gtools<span class="sc">::</span><span class="fu">mixedsort</span>(),</span>
<span id="cb42-1259"><a href="#cb42-1259" aria-hidden="true" tabindex="-1"></a>    <span class="at">gif_file =</span> here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"scratchpad/assignment_state_plot_1.gif"</span>),</span>
<span id="cb42-1260"><a href="#cb42-1260" aria-hidden="true" tabindex="-1"></a>    <span class="at">width =</span> <span class="dv">640</span>, <span class="at">height =</span> <span class="dv">480</span>,</span>
<span id="cb42-1261"><a href="#cb42-1261" aria-hidden="true" tabindex="-1"></a>    <span class="at">delay =</span> <span class="fl">0.25</span>, <span class="at">loop =</span> <span class="cn">TRUE</span>, <span class="at">progress =</span> <span class="cn">TRUE</span></span>
<span id="cb42-1262"><a href="#cb42-1262" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb42-1263"><a href="#cb42-1263" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb42-1264"><a href="#cb42-1264" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb42-1265"><a href="#cb42-1265" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1266"><a href="#cb42-1266" aria-hidden="true" tabindex="-1"></a><span class="al">![](assignment_state_plot_1.gif)</span></span>
<span id="cb42-1267"><a href="#cb42-1267" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1268"><a href="#cb42-1268" aria-hidden="true" tabindex="-1"></a><span class="fu">## Remarks on the Multi-arm bandit approach</span></span>
<span id="cb42-1269"><a href="#cb42-1269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1270"><a href="#cb42-1270" aria-hidden="true" tabindex="-1"></a>Compared to the sequentially greedy approach, the multi-arm bandit approach can be computationally less expensive but there is a higher risk of settling in a local optima. However as the number of dimensions $d$ increases the number of actions grows to $d^2$ meaning that there will be large search space for the multi-arm bandit solution to explore and exploit. This is where I believe a pure exploration method combined with a beam search would be beneficial to ensure that a local optima is reached.</span>
<span id="cb42-1271"><a href="#cb42-1271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1272"><a href="#cb42-1272" aria-hidden="true" tabindex="-1"></a><span class="fu"># Discussion and Review{#sec-review}</span></span>
<span id="cb42-1273"><a href="#cb42-1273" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1274"><a href="#cb42-1274" aria-hidden="true" tabindex="-1"></a><span class="fu">## Remarks on the original paper</span></span>
<span id="cb42-1275"><a href="#cb42-1275" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1276"><a href="#cb42-1276" aria-hidden="true" tabindex="-1"></a>The concept of anchors is an interesting approach to the topic of providing local explanations of black box models. Using human comprehensible decision rules defined as bounding boxes (a list of predicates) to explain the model's decision process around the local instance makes it easier for humans to build trust with black box models. Anchors also gives the user the ability to predict the model behaviour for unseen instances thereby being able to extract new insights from models built on top of complex data. </span>
<span id="cb42-1277"><a href="#cb42-1277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1278"><a href="#cb42-1278" aria-hidden="true" tabindex="-1"></a>However, the approach taken to achieve this task seems to be, in my personal opinion, unnecessarily complicated to accommodate a wide range of tasks. The reasoning behind such a stance is that exploring a finite set of possible bounding boxes in a high dimensional space while being computationally efficient should not require iterative solutions that do not guarantee optimal solutions. The usage of perturbation distributions has been a limitation in previous methods, as it restricts the method of generating samples to a particular distribution which might not be similar to the data generating distribution. </span>
<span id="cb42-1279"><a href="#cb42-1279" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1280"><a href="#cb42-1280" aria-hidden="true" tabindex="-1"></a><span class="fu">## Discussion on reproducing approach</span></span>
<span id="cb42-1281"><a href="#cb42-1281" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1282"><a href="#cb42-1282" aria-hidden="true" tabindex="-1"></a>In terms of the attempt to simplify the implementation of anchors, this report provides an intuition behind the thinking process of the existing paper. </span>
<span id="cb42-1283"><a href="#cb42-1283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1284"><a href="#cb42-1284" aria-hidden="true" tabindex="-1"></a>In addition to demystifying anchors, I have also brought in the following propositions / changes to the existing approach in this report</span>
<span id="cb42-1285"><a href="#cb42-1285" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1286"><a href="#cb42-1286" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Using the area covered within the feature space to compute the coverage instead of using a perturbation distribution. (see @sec-prop-cover-area)</span>
<span id="cb42-1287"><a href="#cb42-1287" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>Using a top down approach instead of a bottom up approach to building anchors. (see @sec-demo-single-inst)</span>
<span id="cb42-1288"><a href="#cb42-1288" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Using the UCB algorithm instead of the KL-LUCB algorithm to demonstrate the need for a pure exploration approach as the multi-arm bandit solution. (see @sec-ucb-algo)</span>
<span id="cb42-1289"><a href="#cb42-1289" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>Providing the intuition of anchors in the following scenarios.</span>
<span id="cb42-1290"><a href="#cb42-1290" aria-hidden="true" tabindex="-1"></a><span class="ss">  1. </span>A brute force approach in one dimension (see @sec-brute-force-oned)</span>
<span id="cb42-1291"><a href="#cb42-1291" aria-hidden="true" tabindex="-1"></a><span class="ss">  2. </span>A sequentially greedy approach in two dimensions (see @sec-seq-greedy)</span>
<span id="cb42-1292"><a href="#cb42-1292" aria-hidden="true" tabindex="-1"></a><span class="ss">  3. </span>A multi-arm bandit approach in two dimensions (see @sec-mab-twod)</span>
<span id="cb42-1293"><a href="#cb42-1293" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>Implementing a pure R solution using novel data structures to ease debugging and encourage understanding of how anchors work. (see @sec-def-anchors)</span>
<span id="cb42-1294"><a href="#cb42-1294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1295"><a href="#cb42-1295" aria-hidden="true" tabindex="-1"></a>Based on the results of the report, the usage of a sequentially greedy approach has proven to be quite useful while trying to use the UCB algorithm as a balance between exploitation and exploration has proven to be detrimental. One drawback of the approach given in this document compared to the approach given in the paper is that for a dataset of $p$ variables, there will be $2 \cdot p$ decision rules which is both restrictive and hard for people to comprehend. In addition, this report is limited to tabular examples only and while it is possible to extend a similar idea to images, it would be beneficial to have decision rules built for tabular rather than images and text where the data itself requires visual explanations.</span>
<span id="cb42-1296"><a href="#cb42-1296" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1297"><a href="#cb42-1297" aria-hidden="true" tabindex="-1"></a><span class="fu">### Software packages used to implement anchors</span></span>
<span id="cb42-1298"><a href="#cb42-1298" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1299"><a href="#cb42-1299" aria-hidden="true" tabindex="-1"></a>This report was written entirely in Quarto while the implementation was done completely on R using several R packages including <span class="in">`S7`</span><span class="co">[</span><span class="ot">@S7_R_pkg</span><span class="co">]</span>, <span class="in">`purrr`</span><span class="co">[</span><span class="ot">@purrr_R_pkg</span><span class="co">]</span>, <span class="in">`dplyr`</span><span class="co">[</span><span class="ot">@dplyr_R_pkg</span><span class="co">]</span>, <span class="in">`ggplot2`</span><span class="co">[</span><span class="ot">@ggplot2_R_pkg</span><span class="co">]</span>.</span>
<span id="cb42-1300"><a href="#cb42-1300" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1301"><a href="#cb42-1301" aria-hidden="true" tabindex="-1"></a><span class="fu">## Conclusions</span></span>
<span id="cb42-1302"><a href="#cb42-1302" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1303"><a href="#cb42-1303" aria-hidden="true" tabindex="-1"></a>Overall, regardless of the semantics of the implementation, based on the results of the evaluation data, anchors has performed comparatively better than LIME, another popular explainable AI method. The simplified approach is a good initiative to explain the construction of anchors to educate and encourage researchers to use anchors in their modelling pipeline. Bridging the knowledge gap in complex tools can help users identify the reasoning behind the different techniques employed by the underlying tools that they use.</span>
<span id="cb42-1304"><a href="#cb42-1304" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1305"><a href="#cb42-1305" aria-hidden="true" tabindex="-1"></a><span class="co">&lt;!-- Simply put what I want this document to flow is to take them through the journey by first explaining </span></span>
<span id="cb42-1306"><a href="#cb42-1306" aria-hidden="true" tabindex="-1"></a><span class="co">what explainable AI is, and why it is important and what are the different variations of explainable AI</span></span>
<span id="cb42-1307"><a href="#cb42-1307" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1308"><a href="#cb42-1308" aria-hidden="true" tabindex="-1"></a><span class="co">Then I will come in to talk about what anchors is and relate it to LIME and counterfactuals?</span></span>
<span id="cb42-1309"><a href="#cb42-1309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1310"><a href="#cb42-1310" aria-hidden="true" tabindex="-1"></a><span class="co">After that I will start off by fleshing my story on anchors. </span></span>
<span id="cb42-1311"><a href="#cb42-1311" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-1312"><a href="#cb42-1312" aria-hidden="true" tabindex="-1"></a><span class="co">First formally define what an anchor is according to the authors. </span></span>
<span id="cb42-1313"><a href="#cb42-1313" aria-hidden="true" tabindex="-1"></a><span class="co">So to do that you will need to talk about what a predicate is and what a perturbation distribution is and what coverage and precision is. Then define the problem statement to finding anchors. and then explain how the authors have decided to find it. Give an overview of how you are going to construct anchors in an intuitive way by showcasing why the authors have decided to construct their solution in such a manner by demonstrating it for one dimensional, two dimensional data with two approaches. finally wrap up the document with an explaination of what the paper is lacking and what could be improved and where they have excelled.  --&gt;</span></span>
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->



</body></html>