---
title: "N dimensional anchors"
format: html
---

```{r}
library(S7)
library(tidyverse) # getting a sword to cut a sandwich
library(patchwork)
library(randomForest)
library(furrr)
library(progressr)
theme_set(theme_minimal())
```

```{r}
predicate <- new_class("predicate", 
  properties = list(
    feature = class_character,
    operator = class_function,
    constant = new_union(
      class_integer, class_double, class_character
    )
  ),
  validator = function(self) {
  }
)

#| code-fold: true
anchors <- new_class("anchors",
  properties = list(
    predicates = class_vector # a vector of predicate class
  ),
  validator = function(self) {
    if(!all(sapply(self@predicates, \(x) S7_inherits(x, predicate)))) {
      return("The list of predicates should all inherit from the predicate class ")
    }
  }
)
```


```{r}
extend <- S7::new_generic("extend", "x")
#' @param pred The predicate to extend x with
#' @return Extended anchor
S7::method(extend, anchors) <- function(x, pred) {
  x@predicates <- c(x@predicates, pred)
  return(x)
}
```

```{r}
satisfies <- S7::new_generic("satisfies", "x")
#' @param data The dataframe to apply anchors on. Can be one instance or an entire dataset.
#' @return A logical vector indicating whether the anchors satisfies `data`
S7::method(satisfies, anchors) <- function(x, data) {
  predicate_cols <- sapply(x@predicates, \(x) x@feature)
  if (!all(predicate_cols %in% colnames(data))) {
    stop(glue::glue(
      "Predicates contain the following columns \n {predicate_cols}\n",
      "that might not be in the dataset with the following columns \n {colnames(data)}"
    ))
  }
  satis_list <- rep(TRUE, nrow(data))
  for (predicate in x@predicates) {
    result_list <- predicate@operator(data[[predicate@feature]], predicate@constant)
    satis_list <- satis_list & result_list
  }
  return(satis_list)
}
```


```{r}
precision <- S7::new_generic("precision", "x")
#' @param model a predict function that will provide the predicted labels given a dataset
#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.
#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)
#' @return named vector of proportions
S7::method(precision, anchors) <- function(x, model, dist, n_samples = 100) {
  samples <- dist(n = n_samples)
  satisfying_rows <- which(satisfies(x, samples), arr.ind = TRUE)
  if(length(satisfying_rows) == 0) {
    message("No satisfying rows found in samples")
    return(NULL)
  }
  samples <- samples |>
    dplyr::slice(satisfying_rows)
  preds <- model(samples)
  return(prop = as.vector(table(preds) / sum(table(preds))))
}
```


```{r}
coverage <- S7::new_generic("coverage", "x")
#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.
#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)
S7::method(coverage, anchors) <- function(x, dist, n_samples = 100) {
  samples <- dist(n = n_samples)
  return(mean(satisfies(x, samples)))
}
```


```{r}
coverage_area <- S7::new_generic("coverage_area", "x")
#' @param dataset the dataset used to calculate the area upon
S7::method(coverage_area, anchors) <- function(x, dataset) {
  little_box <- dataset[satisfies(x, dataset), ]
  return(calculate_area(little_box) / calculate_area(dataset))
}

#' @description Calculates the area of the rectangular shape that encompasses the dataset by getting the range (max - min) of each column and multiplying the value across columns
calculate_area <- function(data) {
  data |> map_dbl(~max(.x, na.rm = T) - min(.x, na.rm = T)) |> prod()
}
```

```{r}
w <- read_csv(here::here("scratchpad/wiggly.csv"),
              col_select = -1,
              col_types = cols(
                x = col_double(),
                y = col_double(),
                class = col_double())) |> 
  mutate(class = factor(ifelse(class == 3, "Positive", "Negative")))

observed_2dim_plot <- w |> 
  ggplot(aes(x = x,y = y,color = class)) +
  geom_point() +
  labs(title = "Observed data for 2 dimensions") +
  coord_equal()
```


```{r}
set.seed(69420)
train_indices <- sample(nrow(w), round(nrow(w) * 0.8))
train_2dim_plot <- w[train_indices, ] |> 
  ggplot(aes(x = x,y = y,color = class)) +
  geom_point() +
  labs(title = "Training data") + 
  coord_equal()
```

```{r}
train_df <- w[train_indices, ] |> mutate(id = row_number())
library(randomForest)
rfmodel <- randomForest(class ~ x + y, data = train_df, ntree = 5)
```

```{r}
prob_matrix <- predict(rfmodel, newdata = train_df, type = "prob") |> 
  as.data.frame() |>
  mutate(id = row_number())
local_instance <- prob_matrix[prob_matrix$Negative == 0.4, "id"]
local_instance <- local_instance[1]
```

```{r}
x_vals <- train_df[-local_instance,][["x"]] |> sort()
x_cutpoints <- purrr::map2_dbl(x_vals[-length(x_vals)], x_vals[-1], function(x, x_1) {
  return(mean(c(x, x_1)))
})
x_grid <- expand.grid(
  x_cutpoints[x_cutpoints < train_df[local_instance,]$x],
  x_cutpoints[x_cutpoints > train_df[local_instance,]$x]
) |> 
  rename(L = Var1, U = Var2)|> 
  as_tibble() |>
  arrange(desc(L), U)

y_vals <- train_df[-local_instance,][["y"]] |> sort()
y_cutpoints <- purrr::map2_dbl(y_vals[-length(y_vals)], y_vals[-1], function(x, x_1) {
  return(mean(c(x, x_1)))
})
y_grid <- expand.grid(
  y_cutpoints[y_cutpoints < train_df[local_instance,]$y],
  y_cutpoints[y_cutpoints > train_df[local_instance,]$y]
) |> 
  rename(L = Var1, U = Var2) |> 
  as_tibble() |>
  arrange(desc(L), U)
```


```{r}
pertub_func <- function(n) {
  mulgar::rmvn(n = n, 
               p = 2,
               mn = train_df[local_instance, c("x", "y")] |> 
                 unlist(),
               vc = cov(train_df[,c("x", "y")])
  ) |>
    as.data.frame() |>
    rename(x = x1, y = x2)
}

model_func <- function(data_samples) {
  suppressPackageStartupMessages(library(randomForest)) # for future package
  return(predict(rfmodel, data_samples))
}

set.seed(123)
samples <- pertub_func(n = 10000)
dist_func <- function(n) samples[1:n, ]
```

```{r}
create_anchor_inst <- function(bounds) {
  pred_vec <- c()
  feat_vec <- rep(c("x", "y"), each = 2)
  op_vec <- rep(c(`>`, `<`), times = 2)
  bound_var <- colnames(bounds)
  for(i in seq(1,4)) {
    pred_vec <- c(pred_vec, predicate(feat_vec[i], op_vec[i][[1]], constant = bounds[[bound_var[i]]]))
  }
  anchor_box <- anchors(pred_vec)
  return(anchor_box)
}
```


we are going to try a top down approach

```{r}
fgrid <- expand_grid(
            x_grid |> rename(X_L = L, X_U = U),
            y_grid |> rename(Y_L = L, Y_U = U)
        ) |>
  arrange(X_L, desc(X_U), Y_L, desc(Y_U))
sgrid <- fgrid |> slice(seq(1,nrow(fgrid),by = 1000))
plan(multisession, workers = 4)
find_prec_cover <- function(bounds, index, progress_bar) {
  progress_bar()
  anchor_box <- create_anchor_inst(bounds)
  cover <- coverage_area(anchor_box, train_df |> select(x, y))
  prec <- precision(anchor_box, model_func, dist_func, n_samples = 1000)
  return(tibble(id = index, cover = cover,prec = prec, class = c("1", "2")))
}
with_progress({
  p <- progressor(steps = nrow(sgrid))
  sgrid_vals <- split(sgrid,seq(1,nrow(sgrid))) |> 
    imap_dfr(find_prec_cover, progress_bar = p #,
      # .options = furrr_options(
      #   globals = c("satisfies", "predicate", "anchors", "coverage_area", "precision", "extend", "dist_func", "model_func", "rfmodel", "train_df", "calculate_area", "samples", "create_anchor_inst", "select")
      # )
    )  
})
```

sgrid contains the possible states to go to from the current state.

```{r}
envir <- sgrid |> 
  mutate(
    X_L_r = rank(X_L, ties.method = "first"),
    X_U_r = rank(-X_U, ties.method = "first"),
    Y_L_r = rank(Y_L, ties.method = "first"),
    Y_U_r = rank(-Y_U, ties.method = "first"),
    id = row_number()
  ) |>
  arrange(X_L_r,X_U_r,Y_L_r,Y_U_r) |>
  left_join(
    sgrid_vals |>
      mutate(class = paste0("class_", class), id = as.numeric(id)) |> 
      pivot_wider(names_from = "class", values_from = "prec"),
    by = "id") # kinda unnecessary
actions <- colnames(sgrid)
```

```{r}
PENALTY_VALUE = -9999
get_reward <- function(inst_row, class_ind = 1) {
  prec <- envir |> filter(id == inst_row$id) |> pull(paste0("class_", class_ind))
  cover <- envir |> filter(id == inst_row$id) |> pull("cover")
  if (is.null(prec)) return(PENALTY_VALUE) # penalty
  if (prec < 0.5) return(PENALTY_VALUE) # penalty for wrong direction
  # if (cover == 0) return(PENALTY_VALUE)
  print(glue::glue("reward precision {round(prec, 2)} and coverage {round(cover, 2)}"))
  return(sqrt(cover) + (prec - 0.6))
}

select_action <- function(Q, N, n_game, possible_actions = actions) {
  rewards <- map_dbl(possible_actions, function(a){
    Q_star[[a]] + Q[[a]] + sqrt((2 * log(n_game)) / N[[a]])
  })
  print(glue::glue("selection criteria {paste(round(rewards,2), collapse = ',')}"))
  if(sum(rewards == max(rewards)) > 1) {
    max_reward <- sample(which(rewards == max(rewards)), 1)
  } else {
    max_reward <- which.max(rewards)  
  }
  # return(sample(possible_actions, 1))
  return(actions[max_reward])
}
```

```{r}
n_games <- 5
n_epochs <- 100
id_list <- lapply(seq(n_games), \(x) vector(mode = "numeric", length = n_epochs))
plot_list <- lapply(seq(n_games), \(x) lapply(seq(n_epochs), \(x) return(ggplot())))
```

```{r}
Q_star <- lapply(actions, \(x) return(0)) |> setNames(actions)
for(game in seq_len(n_games)) {
  cli::cli_h1(glue::glue("Starting game {game}"))
  current_bound <- envir[1, ]
  N <- lapply(actions, \(x) return(0)) |> setNames(actions)
  Q <- lapply(actions, \(x) return(0)) |> setNames(actions)
  
  # initial round to explore all arms
  for(action in actions) {
    temp_bound <- envir[ envir[[paste0(action, "_r")]] == (current_bound[[paste0(action, "_r")]] + 1), ]
    if(nrow(temp_bound) == 0) {
      reward <- PENALTY_VALUE
    } else {
      reward <- get_reward(temp_bound)  
    }
    
    N[[action]] <- N[[action]] + 1
    Q[[action]] <- reward
    print(glue::glue("Q : {paste(Q, collapse = ',')} N: {paste(N, collapse = ',')}"))
  }
  
  for(epoch in seq_len(n_epochs)) {
    cli::cli_h2(glue::glue("Starting epoch {epoch}"))
    action <- select_action(Q, N, game)
    temp_bound <- envir[ envir[[paste0(action, "_r")]] == (current_bound[[paste0(action, "_r")]] + 1), ]
    while(nrow(temp_bound) == 0) {
      action <- select_action(Q, N, game)
      temp_bound <- envir[ envir[[paste0(action, "_r")]] == (current_bound[[paste0(action, "_r")]] + 1), ]     
    }
    reward <- get_reward(temp_bound)
    current_bound <- temp_bound  
    id_list[[game]][epoch] <- current_bound$id
    N[[action]] <- N[[action]] + 1
    if(Q[[action]] <= 0) {
      Q[[action]] <- reward
    } else {
      Q[[action]] <- Q[[action]] + ((reward - Q[[action]]) / N[[action]])
    }
    print(glue::glue("Q : {paste(Q, collapse = ',')} N: {paste(N, collapse = ',')}"))
    
    state_plot <- train_df[-local_instance, ] |>
        ggplot(aes(x = x,y = y,color = class)) +
          geom_point() +
          geom_point(data = train_df[local_instance, ], 
                     size = 1, color = "black") +
          geom_label(data = train_df[local_instance, ], 
                     label = "Here", color = "black", nudge_y = 0.05) +
          geom_rect(inherit.aes = F,
                    data = current_bound |> select(X_L, X_U, Y_L, Y_U),
            aes(xmin = X_L, xmax = X_U, ymin = Y_L, ymax = Y_U),
            fill = "transparent", color = "black") +
          labs(title = glue::glue("Game: {game}, round: {epoch}, reward: {round(reward,2)}")) +
          theme(legend.position = "bottom")
      # ggsave(
      #   plot = state_plot,
      #   filename = here::here(
      #     "scratchpad/n_dim_state_plot_dump_1/",
      #     glue::glue("{game}_{epoch}.png")
      #   ),
      #   device = "png", bg = "white", width = 11, height = 8, units = "in"
      # )
      plot_list[[game]][[epoch]] <- state_plot
  }
  Q_star <<- imap(Q, function(val, name) {(Q_star[[name]] + val) / n_games})
}
```


```{r}
uniq_ids <- unlist(id_list) |> unique()
id_plots <- imap(uniq_ids, function(id, index) {
  id_plot <- ggplot() +
    geom_point(data = envir[envir$id != id, ], aes(x = class_1, y = cover), alpha = 0.001) +
    geom_point(data = envir[envir$id == id, ], aes(x = class_1, y = cover), color = "red", size = 2)
  if(index > 2) {
    id_plot <- id_plot + 
      geom_point(data = envir[envir$id %in% uniq_ids[seq(1, index)], ], aes(x = class_1, y = cover), color = "red", alpha = 0.1)
  }
  id_plot + labs(title = "Precision coverage plot")
})
names(id_plots) <- paste0("id_plot_", uniq_ids)
```

```{r}
library(patchwork)
sidebside <- map2(unlist(id_list), list_flatten(plot_list), function(visit_id, state_plot_){
  id_plots[[paste0("id_plot_", visit_id)]] + state_plot_
}) 
```

```{r}
iwalk(sidebside, function(p, i){
  ggsave(p, filename = here::here("scratchpad/n_dim_state_plot_dump_1/",paste0(i,".png")),
       device = "png", bg = "white", dpi = 72, height = 4, width = 6, units = "in")
})
```

```{r}
library(gifski)
gifski(
  png_files = list.files(
    here::here("scratchpad/n_dim_state_plot_dump_1/"),
    pattern = "*.png",
    full.names = TRUE),
  gif_file = here::here("scratchpad/n_dim_state_plot_1.gif"),
  width = 1280, height = 720,
  delay = 0.5, loop = TRUE, progress = TRUE
)
```


