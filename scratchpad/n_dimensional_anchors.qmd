---
title: "N dimensional anchors"
format: html
---

```{r}
library(S7)
library(tidyverse) # getting a sword to cut a sandwich
library(patchwork)
library(randomForest)
library(furrr)
library(progressr)
theme_set(theme_minimal())
```

```{r}
predicate <- new_class("predicate", 
  properties = list(
    feature = class_character,
    operator = class_function,
    constant = new_union(
      class_integer, class_double, class_character
    )
  ),
  validator = function(self) {
  }
)

#| code-fold: true
anchors <- new_class("anchors",
  properties = list(
    predicates = class_vector # a vector of predicate class
  ),
  validator = function(self) {
    if(!all(sapply(self@predicates, \(x) S7_inherits(x, predicate)))) {
      return("The list of predicates should all inherit from the predicate class ")
    }
  }
)
```


```{r}
extend <- S7::new_generic("extend", "x")
#' @param pred The predicate to extend x with
#' @return Extended anchor
S7::method(extend, anchors) <- function(x, pred) {
  x@predicates <- c(x@predicates, pred)
  return(x)
}
```

```{r}
satisfies <- S7::new_generic("satisfies", "x")
#' @param data The dataframe to apply anchors on. Can be one instance or an entire dataset.
#' @return A logical vector indicating whether the anchors satisfies `data`
S7::method(satisfies, anchors) <- function(x, data) {
  predicate_cols <- sapply(x@predicates, \(x) x@feature)
  if (!all(predicate_cols %in% colnames(data))) {
    stop(glue::glue(
      "Predicates contain the following columns \n {predicate_cols}\n",
      "that might not be in the dataset with the following columns \n {colnames(data)}"
    ))
  }
  satis_list <- rep(TRUE, nrow(data))
  for (predicate in x@predicates) {
    result_list <- predicate@operator(data[[predicate@feature]], predicate@constant)
    satis_list <- satis_list & result_list
  }
  return(satis_list)
}
```


```{r}
precision <- S7::new_generic("precision", "x")
#' @param model a predict function that will provide the predicted labels given a dataset
#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.
#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)
#' @return named vector of proportions
S7::method(precision, anchors) <- function(x, model, dist, n_samples = 100) {
  samples <- dist(n = n_samples)
  satisfying_rows <- which(satisfies(x, samples), arr.ind = TRUE)
  if(length(satisfying_rows) == 0) {
    message("No satisfying rows found in samples")
    return(NULL)
  }
  samples <- samples |>
    dplyr::slice(satisfying_rows)
  preds <- model(samples)
  return(prop = as.vector(table(preds) / sum(table(preds))))
}
```


```{r}
coverage <- S7::new_generic("coverage", "x")
#' @param dist the function that can be used to generate samples by providing an argument n. Should return a dataframe with proper column names.
#' @param n_samples the number of samples to generate from `dist` (the perturbation distribution)
S7::method(coverage, anchors) <- function(x, dist, n_samples = 100) {
  samples <- dist(n = n_samples)
  return(mean(satisfies(x, samples)))
}
```


```{r}
coverage_area <- S7::new_generic("coverage_area", "x")
#' @param dataset the dataset used to calculate the area upon
S7::method(coverage_area, anchors) <- function(x, dataset) {
  little_box <- dataset[satisfies(x, dataset), ]
  return(calculate_area(little_box) / calculate_area(dataset))
}

#' @description Calculates the area of the rectangular shape that encompasses the dataset by getting the range (max - min) of each column and multiplying the value across columns
calculate_area <- function(data) {
  data |> map_dbl(~max(.x, na.rm = T) - min(.x, na.rm = T)) |> prod()
}
```

```{r}
w <- read_csv(here::here("scratchpad/wiggly.csv"),
              col_select = -1,
              col_types = cols(
                x = col_double(),
                y = col_double(),
                class = col_double())) |> 
  mutate(class = factor(ifelse(class == 3, "Positive", "Negative")))

observed_2dim_plot <- w |> 
  ggplot(aes(x = x,y = y,color = class)) +
  geom_point() +
  labs(title = "Observed data for 2 dimensions") +
  coord_equal()
```


```{r}
set.seed(69420)
train_indices <- sample(nrow(w), round(nrow(w) * 0.8))
train_2dim_plot <- w[train_indices, ] |> 
  ggplot(aes(x = x,y = y,color = class)) +
  geom_point() +
  labs(title = "Training data") + 
  coord_equal()
```

```{r}
train_df <- w[train_indices, ] |> mutate(id = row_number())
library(randomForest)
rfmodel <- randomForest(class ~ x + y, data = train_df, ntree = 5)
```

```{r}
prob_matrix <- predict(rfmodel, newdata = train_df, type = "prob") |> 
  as.data.frame() |>
  mutate(id = row_number())
local_instance <- prob_matrix[prob_matrix$Negative == 0.4, "id"]
local_instance <- local_instance[1]
```

```{r}
x_vals <- train_df[-local_instance,][["x"]] |> sort()
x_cutpoints <- purrr::map2_dbl(x_vals[-length(x_vals)], x_vals[-1], function(x, x_1) {
  return(mean(c(x, x_1)))
})
x_l <- sort(
  x_cutpoints[x_cutpoints < train_df[local_instance,]$x],
  decreasing = TRUE
)
x_u <- x_cutpoints[x_cutpoints > train_df[local_instance,]$x]

y_vals <- train_df[-local_instance,][["y"]] |> sort()
y_cutpoints <- purrr::map2_dbl(y_vals[-length(y_vals)], y_vals[-1], function(x, x_1) {
  return(mean(c(x, x_1)))
})
y_l <- sort(
  y_cutpoints[y_cutpoints < train_df[local_instance,]$y],
  decreasing = TRUE
)
y_u <- y_cutpoints[y_cutpoints > train_df[local_instance,]$y]
```


```{r}
pertub_func <- function(n) {
  mulgar::rmvn(n = n, 
               p = 2,
               mn = train_df[local_instance, c("x", "y")] |> 
                 unlist(),
               vc = cov(train_df[,c("x", "y")])
  ) |>
    as.data.frame() |>
    rename(x = x1, y = x2)
}

model_func <- function(data_samples) {
  suppressPackageStartupMessages(library(randomForest)) # for future package
  return(predict(rfmodel, data_samples))
}

set.seed(123)
samples <- pertub_func(n = 10000)
dist_func <- function(n) samples[1:n, ]
```

Going to try Thompson sampling in the end

```{r}
set.seed(123)
# actions <- c("NW", "NE", "SW", "SE")
actions <- list(c(1,0,0,1), c(0,1,0,1), c(1,0,1,0), c(0,1,1,0))
n_actions <- length(actions)
envir <- list(
  x_l, x_u, y_l, y_u
)
update_bounds <- function(current_envir, selected_action) {
  new_bound <- current_envir + actions[[selected_action]]
  for(i in seq_along(new_bound)) {
    if(is.na(envir[[i]][new_bound[i]])) {
      new_bound[i] <- current_envir[i]
    }
  }
  return(new_bound)
}

envir_to_bounds <- function(current_envir) {
  bounds <- tibble(X_L = NA, X_U = NA, Y_L = NA, Y_U = NA)
  for(i in seq_along(current_envir)) {
    bounds[1,i] <- envir[[i]][current_envir[i]]
  }
  return(bounds)
}
create_anchor_inst <- function(bounds) {
  pred_vec <- c()
  feat_vec <- rep(c("x", "y"), each = 2)
  op_vec <- rep(c(`>`, `<`), times = 2)
  bound_var <- colnames(bounds)
  for(i in seq(1,4)) {
    pred_vec <- c(pred_vec, predicate(feat_vec[i], op_vec[i][[1]], constant = bounds[[bound_var[i]]]))
  }
  anchor_box <- anchors(pred_vec)
  return(anchor_box)
}

get_reward <- function(new_anchor, class_ind = 1) {
  cover <- coverage_area(new_anchor, train_df |> select(x, y))
  prec <- precision(new_anchor, model_func, dist_func, n_samples = 10000)
  prec <- prec[class_ind]
  if(is.null(prec)) prec <- 0
  if(is.infinite(cover)) cover <- 0
  print(glue::glue("==== {cover} | {prec} | {mean(c(cover, prec), na.rm = TRUE) }====="))
  return(list(
    reward = mean(c(cover, prec), na.rm = TRUE),
    prec = prec, cover = cover
    ))
}

A <- rep(1, n_actions)
B <- rep(1, n_actions)
n_games <- 5
n_epochs <- 100
plot_list <- lapply(seq(n_games), \(x) lapply(seq(n_epochs), \(x) return(ggplot())))
prec_cover_hist <- tibble(game = numeric(), round = numeric(), prec = numeric(), cover = numeric())
for(game in seq_len(n_games)) {
  current_envir <- rep(1, n_actions)
  for(round in seq_len(n_epochs)) {
    r <- vector(mode = "numeric", length = n_actions)
    for(i_action in seq_len(n_actions)) {
      r[i_action] <- rbeta(1, shape1 = A[i_action], B[i_action])
    }
    selected_action <- which.max(r)
    current_envir <- update_bounds(current_envir, selected_action)
    new_anchor <- envir_to_bounds(current_envir) |> create_anchor_inst()
    reward <- get_reward(new_anchor)
    outcome <- rbinom(1, size = 1, prob = reward$reward)
    if(outcome == 1) {
      A[selected_action] <- A[selected_action] + 1 
    } else {
      B[selected_action] <- B[selected_action] + 1
    }
    print(glue::glue("Game {game}: Round {round}\n selected : {selected_action}\n prec: {round(reward$prec, 4)}  | cover: {round(reward$cover, 4)} | reward: {round(reward$reward,4)} \n outcome: {outcome}"))
    prec_cover_hist <- rbind(prec_cover_hist, tibble(game = game, round = round, prec = reward$prec, cover = reward$cover))
    state_plot <- train_df[-local_instance, ] |>
      ggplot(aes(x = x,y = y,color = class)) +
        geom_point() +
        geom_point(data = train_df[local_instance, ], 
                    size = 1) +
        geom_label(data = train_df[local_instance, ], 
                    label = "Here", color = "black", nudge_y = 0.05) +
        geom_rect(inherit.aes = F,
                  data = envir_to_bounds(current_envir) |> select(X_L, X_U, Y_L, Y_U),
          aes(xmin = X_L, xmax = X_U, ymin = Y_L, ymax = Y_U),
          fill = "transparent", color = "black") +
        labs(title = glue::glue("Game: {game}, round: {round}, reward: {round(reward$reward,2)}")) +
        theme(legend.position = "bottom")
    plot_list[[game]][[round]] <- state_plot
  }
}
```


```{r}
library(patchwork)
prec_cover_hist <- prec_cover_hist |> mutate(ith = row_number())
sidebside <- prec_cover_hist |> split(seq(1,nrow(prec_cover_hist))) |> 
  map(function(r) {
    ith_place <- r$ith
    path_plot <- ggplot() +
      geom_point(
        data = prec_cover_hist |> filter(ith < ith_place),
        aes(x = prec, y = cover),
        color = "red", alpha = 0.1
      ) +
      geom_point(
        data = r,
        aes(x = prec, y = cover),
        color = "red", size = 2
      ) + 
      lims(x = c(0,1), y = c(0,1)) +
      labs(
        x = "Precision", y = "Coverage",
        title = glue::glue("Game: {r$game}, round: {r$round}")
      )
    path_plot + plot_list[[r$game]][[r$round]]
  })
```

```{r}
iwalk(sidebside, function(p, i){
  ggsave(p, filename = here::here("scratchpad/n_dim_state_plot_dump_2/",paste0(i,".png")),
       device = "png", bg = "white", dpi = 72, height = 600, width = 1200, units = "px")
})
```

```{r}
library(gifski)
gifski(
  png_files = list.files(
    here::here("scratchpad/n_dim_state_plot_dump_2/"),
    pattern = "*.png",
    full.names = TRUE) |> gtools::mixedsort(),
  gif_file = here::here("scratchpad/n_dim_state_plot_2.gif"),
  delay = 0.25,
  width = 1200, height = 600, loop = TRUE, progress = TRUE
)
```
